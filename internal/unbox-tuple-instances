#ifdef DEFINE_INSTANCES
data instance MVector s (a, b)
    = MV_2 {-# UNPACK #-} !Int (MVector s a)
                               (MVector s b)
data instance Vector (a, b)
    = V_2 {-# UNPACK #-} !Int (Vector a)
                              (Vector b)
instance (Unbox a, Unbox b) => Unbox (a, b)
instance (Unbox a, Unbox b) => M.MVector MVector (a, b) where
  {-# INLINE basicLength  #-}
  basicLength (MV_2 n_ as bs) = n_
  {-# INLINE basicUnsafeSlice  #-}
  basicUnsafeSlice (MV_2 n_ as bs) i_ m_
      = MV_2 m_ (M.basicUnsafeSlice as i_ m_)
                (M.basicUnsafeSlice bs i_ m_)
  {-# INLINE basicOverlaps  #-}
  basicOverlaps (MV_2 n_1 as1 bs1) (MV_2 n_2 as2 bs2)
      = M.basicOverlaps as1 as2
        || M.basicOverlaps bs1 bs2
  {-# INLINE basicUnsafeNew  #-}
  basicUnsafeNew n_
      = do
          as <- M.basicUnsafeNew n_
          bs <- M.basicUnsafeNew n_
          return $ MV_2 n_ as bs
  {-# INLINE basicUnsafeNewWith  #-}
  basicUnsafeNewWith n_ (a, b)
      = do
          as <- M.basicUnsafeNewWith n_ a
          bs <- M.basicUnsafeNewWith n_ b
          return $ MV_2 n_ as bs
  {-# INLINE basicUnsafeRead  #-}
  basicUnsafeRead (MV_2 n_ as bs) i_
      = do
          a <- M.basicUnsafeRead as i_
          b <- M.basicUnsafeRead bs i_
          return (a, b)
  {-# INLINE basicUnsafeWrite  #-}
  basicUnsafeWrite (MV_2 n_ as bs) i_ (a, b)
      = do
          M.basicUnsafeWrite as i_ a
          M.basicUnsafeWrite bs i_ b
  {-# INLINE basicClear  #-}
  basicClear (MV_2 n_ as bs)
      = do
          M.basicClear as
          M.basicClear bs
  {-# INLINE basicSet  #-}
  basicSet (MV_2 n_ as bs) (a, b)
      = do
          M.basicSet as a
          M.basicSet bs b
  {-# INLINE basicUnsafeCopy  #-}
  basicUnsafeCopy (MV_2 n_1 as1 bs1) (MV_2 n_2 as2 bs2)
      = do
          M.basicUnsafeCopy as1 as2
          M.basicUnsafeCopy bs1 bs2
  {-# INLINE basicUnsafeGrow  #-}
  basicUnsafeGrow (MV_2 n_ as bs) m_
      = do
          M.basicUnsafeGrow as m_
          M.basicUnsafeGrow bs m_
          return $ MV_2 (m_+n_) as bs
instance (Unbox a, Unbox b) => G.Vector Vector (a, b) where
  {-# INLINE unsafeFreeze  #-}
  unsafeFreeze (MV_2 n_ as bs)
      = do
          as' <- G.unsafeFreeze as
          bs' <- G.unsafeFreeze bs
          return $ V_2 n_ as' bs'
  {-# INLINE basicLength  #-}
  basicLength (V_2 n_ as bs) = n_
  {-# INLINE basicUnsafeSlice  #-}
  basicUnsafeSlice (V_2 n_ as bs) i_ m_
      = V_2 m_ (G.basicUnsafeSlice as i_ m_)
               (G.basicUnsafeSlice bs i_ m_)
  {-# INLINE basicUnsafeIndexM  #-}
  basicUnsafeIndexM (V_2 n_ as bs) i_
      = do
          a <- G.basicUnsafeIndexM as i_
          b <- G.basicUnsafeIndexM bs i_
          return (a, b)
#endif
#ifdef DEFINE_MUTABLE
zip :: (Unbox a, Unbox b) => MVector s a ->
                             MVector s b -> MVector s (a, b)
{-# INLINE zip #-}
zip as bs = MV_2 len (unsafeSlice as 0 len) (unsafeSlice bs 0 len)
  where len = length as `min` length bs
unzip :: (Unbox a, Unbox b) => MVector s (a, b) -> (MVector s a,
                                                    MVector s b)
{-# INLINE unzip #-}
unzip (MV_2 n_ as bs) = (as, bs)
#endif
#ifdef DEFINE_IMMUTABLE
zip :: (Unbox a, Unbox b) => Vector a -> Vector b -> Vector (a, b)
{-# INLINE zip #-}
zip as bs = V_2 len (unsafeSlice as 0 len) (unsafeSlice bs 0 len)
  where len = length as `min` length bs
unzip :: (Unbox a, Unbox b) => Vector (a, b) -> (Vector a,
                                                 Vector b)
{-# INLINE unzip #-}
unzip (V_2 n_ as bs) = (as, bs)
#endif
#ifdef DEFINE_INSTANCES
data instance MVector s (a, b, c)
    = MV_3 {-# UNPACK #-} !Int (MVector s a)
                               (MVector s b)
                               (MVector s c)
data instance Vector (a, b, c)
    = V_3 {-# UNPACK #-} !Int (Vector a)
                              (Vector b)
                              (Vector c)
instance (Unbox a, Unbox b, Unbox c) => Unbox (a, b, c)
instance (Unbox a,
          Unbox b,
          Unbox c) => M.MVector MVector (a, b, c) where
  {-# INLINE basicLength  #-}
  basicLength (MV_3 n_ as bs cs) = n_
  {-# INLINE basicUnsafeSlice  #-}
  basicUnsafeSlice (MV_3 n_ as bs cs) i_ m_
      = MV_3 m_ (M.basicUnsafeSlice as i_ m_)
                (M.basicUnsafeSlice bs i_ m_)
                (M.basicUnsafeSlice cs i_ m_)
  {-# INLINE basicOverlaps  #-}
  basicOverlaps (MV_3 n_1 as1 bs1 cs1) (MV_3 n_2 as2 bs2 cs2)
      = M.basicOverlaps as1 as2
        || M.basicOverlaps bs1 bs2
        || M.basicOverlaps cs1 cs2
  {-# INLINE basicUnsafeNew  #-}
  basicUnsafeNew n_
      = do
          as <- M.basicUnsafeNew n_
          bs <- M.basicUnsafeNew n_
          cs <- M.basicUnsafeNew n_
          return $ MV_3 n_ as bs cs
  {-# INLINE basicUnsafeNewWith  #-}
  basicUnsafeNewWith n_ (a, b, c)
      = do
          as <- M.basicUnsafeNewWith n_ a
          bs <- M.basicUnsafeNewWith n_ b
          cs <- M.basicUnsafeNewWith n_ c
          return $ MV_3 n_ as bs cs
  {-# INLINE basicUnsafeRead  #-}
  basicUnsafeRead (MV_3 n_ as bs cs) i_
      = do
          a <- M.basicUnsafeRead as i_
          b <- M.basicUnsafeRead bs i_
          c <- M.basicUnsafeRead cs i_
          return (a, b, c)
  {-# INLINE basicUnsafeWrite  #-}
  basicUnsafeWrite (MV_3 n_ as bs cs) i_ (a, b, c)
      = do
          M.basicUnsafeWrite as i_ a
          M.basicUnsafeWrite bs i_ b
          M.basicUnsafeWrite cs i_ c
  {-# INLINE basicClear  #-}
  basicClear (MV_3 n_ as bs cs)
      = do
          M.basicClear as
          M.basicClear bs
          M.basicClear cs
  {-# INLINE basicSet  #-}
  basicSet (MV_3 n_ as bs cs) (a, b, c)
      = do
          M.basicSet as a
          M.basicSet bs b
          M.basicSet cs c
  {-# INLINE basicUnsafeCopy  #-}
  basicUnsafeCopy (MV_3 n_1 as1 bs1 cs1) (MV_3 n_2 as2 bs2 cs2)
      = do
          M.basicUnsafeCopy as1 as2
          M.basicUnsafeCopy bs1 bs2
          M.basicUnsafeCopy cs1 cs2
  {-# INLINE basicUnsafeGrow  #-}
  basicUnsafeGrow (MV_3 n_ as bs cs) m_
      = do
          M.basicUnsafeGrow as m_
          M.basicUnsafeGrow bs m_
          M.basicUnsafeGrow cs m_
          return $ MV_3 (m_+n_) as bs cs
instance (Unbox a,
          Unbox b,
          Unbox c) => G.Vector Vector (a, b, c) where
  {-# INLINE unsafeFreeze  #-}
  unsafeFreeze (MV_3 n_ as bs cs)
      = do
          as' <- G.unsafeFreeze as
          bs' <- G.unsafeFreeze bs
          cs' <- G.unsafeFreeze cs
          return $ V_3 n_ as' bs' cs'
  {-# INLINE basicLength  #-}
  basicLength (V_3 n_ as bs cs) = n_
  {-# INLINE basicUnsafeSlice  #-}
  basicUnsafeSlice (V_3 n_ as bs cs) i_ m_
      = V_3 m_ (G.basicUnsafeSlice as i_ m_)
               (G.basicUnsafeSlice bs i_ m_)
               (G.basicUnsafeSlice cs i_ m_)
  {-# INLINE basicUnsafeIndexM  #-}
  basicUnsafeIndexM (V_3 n_ as bs cs) i_
      = do
          a <- G.basicUnsafeIndexM as i_
          b <- G.basicUnsafeIndexM bs i_
          c <- G.basicUnsafeIndexM cs i_
          return (a, b, c)
#endif
#ifdef DEFINE_MUTABLE
zip3 :: (Unbox a, Unbox b, Unbox c) => MVector s a ->
                                       MVector s b ->
                                       MVector s c -> MVector s (a, b, c)
{-# INLINE zip3 #-}
zip3 as bs cs = MV_3 len (unsafeSlice as 0 len)
                         (unsafeSlice bs 0 len)
                         (unsafeSlice cs 0 len)
  where len = length as `min` length bs `min` length cs
unzip3 :: (Unbox a,
           Unbox b,
           Unbox c) => MVector s (a, b, c) -> (MVector s a,
                                               MVector s b,
                                               MVector s c)
{-# INLINE unzip3 #-}
unzip3 (MV_3 n_ as bs cs) = (as, bs, cs)
#endif
#ifdef DEFINE_IMMUTABLE
zip3 :: (Unbox a, Unbox b, Unbox c) => Vector a ->
                                       Vector b ->
                                       Vector c -> Vector (a, b, c)
{-# INLINE zip3 #-}
zip3 as bs cs = V_3 len (unsafeSlice as 0 len)
                        (unsafeSlice bs 0 len)
                        (unsafeSlice cs 0 len)
  where len = length as `min` length bs `min` length cs
unzip3 :: (Unbox a,
           Unbox b,
           Unbox c) => Vector (a, b, c) -> (Vector a, Vector b, Vector c)
{-# INLINE unzip3 #-}
unzip3 (V_3 n_ as bs cs) = (as, bs, cs)
#endif
#ifdef DEFINE_INSTANCES
data instance MVector s (a, b, c, d)
    = MV_4 {-# UNPACK #-} !Int (MVector s a)
                               (MVector s b)
                               (MVector s c)
                               (MVector s d)
data instance Vector (a, b, c, d)
    = V_4 {-# UNPACK #-} !Int (Vector a)
                              (Vector b)
                              (Vector c)
                              (Vector d)
instance (Unbox a, Unbox b, Unbox c, Unbox d) => Unbox (a, b, c, d)
instance (Unbox a,
          Unbox b,
          Unbox c,
          Unbox d) => M.MVector MVector (a, b, c, d) where
  {-# INLINE basicLength  #-}
  basicLength (MV_4 n_ as bs cs ds) = n_
  {-# INLINE basicUnsafeSlice  #-}
  basicUnsafeSlice (MV_4 n_ as bs cs ds) i_ m_
      = MV_4 m_ (M.basicUnsafeSlice as i_ m_)
                (M.basicUnsafeSlice bs i_ m_)
                (M.basicUnsafeSlice cs i_ m_)
                (M.basicUnsafeSlice ds i_ m_)
  {-# INLINE basicOverlaps  #-}
  basicOverlaps (MV_4 n_1 as1 bs1 cs1 ds1) (MV_4 n_2 as2 bs2 cs2 ds2)
      = M.basicOverlaps as1 as2
        || M.basicOverlaps bs1 bs2
        || M.basicOverlaps cs1 cs2
        || M.basicOverlaps ds1 ds2
  {-# INLINE basicUnsafeNew  #-}
  basicUnsafeNew n_
      = do
          as <- M.basicUnsafeNew n_
          bs <- M.basicUnsafeNew n_
          cs <- M.basicUnsafeNew n_
          ds <- M.basicUnsafeNew n_
          return $ MV_4 n_ as bs cs ds
  {-# INLINE basicUnsafeNewWith  #-}
  basicUnsafeNewWith n_ (a, b, c, d)
      = do
          as <- M.basicUnsafeNewWith n_ a
          bs <- M.basicUnsafeNewWith n_ b
          cs <- M.basicUnsafeNewWith n_ c
          ds <- M.basicUnsafeNewWith n_ d
          return $ MV_4 n_ as bs cs ds
  {-# INLINE basicUnsafeRead  #-}
  basicUnsafeRead (MV_4 n_ as bs cs ds) i_
      = do
          a <- M.basicUnsafeRead as i_
          b <- M.basicUnsafeRead bs i_
          c <- M.basicUnsafeRead cs i_
          d <- M.basicUnsafeRead ds i_
          return (a, b, c, d)
  {-# INLINE basicUnsafeWrite  #-}
  basicUnsafeWrite (MV_4 n_ as bs cs ds) i_ (a, b, c, d)
      = do
          M.basicUnsafeWrite as i_ a
          M.basicUnsafeWrite bs i_ b
          M.basicUnsafeWrite cs i_ c
          M.basicUnsafeWrite ds i_ d
  {-# INLINE basicClear  #-}
  basicClear (MV_4 n_ as bs cs ds)
      = do
          M.basicClear as
          M.basicClear bs
          M.basicClear cs
          M.basicClear ds
  {-# INLINE basicSet  #-}
  basicSet (MV_4 n_ as bs cs ds) (a, b, c, d)
      = do
          M.basicSet as a
          M.basicSet bs b
          M.basicSet cs c
          M.basicSet ds d
  {-# INLINE basicUnsafeCopy  #-}
  basicUnsafeCopy (MV_4 n_1 as1 bs1 cs1 ds1) (MV_4 n_2 as2
                                                       bs2
                                                       cs2
                                                       ds2)
      = do
          M.basicUnsafeCopy as1 as2
          M.basicUnsafeCopy bs1 bs2
          M.basicUnsafeCopy cs1 cs2
          M.basicUnsafeCopy ds1 ds2
  {-# INLINE basicUnsafeGrow  #-}
  basicUnsafeGrow (MV_4 n_ as bs cs ds) m_
      = do
          M.basicUnsafeGrow as m_
          M.basicUnsafeGrow bs m_
          M.basicUnsafeGrow cs m_
          M.basicUnsafeGrow ds m_
          return $ MV_4 (m_+n_) as bs cs ds
instance (Unbox a,
          Unbox b,
          Unbox c,
          Unbox d) => G.Vector Vector (a, b, c, d) where
  {-# INLINE unsafeFreeze  #-}
  unsafeFreeze (MV_4 n_ as bs cs ds)
      = do
          as' <- G.unsafeFreeze as
          bs' <- G.unsafeFreeze bs
          cs' <- G.unsafeFreeze cs
          ds' <- G.unsafeFreeze ds
          return $ V_4 n_ as' bs' cs' ds'
  {-# INLINE basicLength  #-}
  basicLength (V_4 n_ as bs cs ds) = n_
  {-# INLINE basicUnsafeSlice  #-}
  basicUnsafeSlice (V_4 n_ as bs cs ds) i_ m_
      = V_4 m_ (G.basicUnsafeSlice as i_ m_)
               (G.basicUnsafeSlice bs i_ m_)
               (G.basicUnsafeSlice cs i_ m_)
               (G.basicUnsafeSlice ds i_ m_)
  {-# INLINE basicUnsafeIndexM  #-}
  basicUnsafeIndexM (V_4 n_ as bs cs ds) i_
      = do
          a <- G.basicUnsafeIndexM as i_
          b <- G.basicUnsafeIndexM bs i_
          c <- G.basicUnsafeIndexM cs i_
          d <- G.basicUnsafeIndexM ds i_
          return (a, b, c, d)
#endif
#ifdef DEFINE_MUTABLE
zip4 :: (Unbox a, Unbox b, Unbox c, Unbox d) => MVector s a ->
                                                MVector s b ->
                                                MVector s c ->
                                                MVector s d -> MVector s (a, b, c, d)
{-# INLINE zip4 #-}
zip4 as bs cs ds = MV_4 len (unsafeSlice as 0 len)
                            (unsafeSlice bs 0 len)
                            (unsafeSlice cs 0 len)
                            (unsafeSlice ds 0 len)
  where
    len = length as `min` length bs `min` length cs `min` length ds
unzip4 :: (Unbox a,
           Unbox b,
           Unbox c,
           Unbox d) => MVector s (a, b, c, d) -> (MVector s a,
                                                  MVector s b,
                                                  MVector s c,
                                                  MVector s d)
{-# INLINE unzip4 #-}
unzip4 (MV_4 n_ as bs cs ds) = (as, bs, cs, ds)
#endif
#ifdef DEFINE_IMMUTABLE
zip4 :: (Unbox a, Unbox b, Unbox c, Unbox d) => Vector a ->
                                                Vector b ->
                                                Vector c ->
                                                Vector d -> Vector (a, b, c, d)
{-# INLINE zip4 #-}
zip4 as bs cs ds = V_4 len (unsafeSlice as 0 len)
                           (unsafeSlice bs 0 len)
                           (unsafeSlice cs 0 len)
                           (unsafeSlice ds 0 len)
  where
    len = length as `min` length bs `min` length cs `min` length ds
unzip4 :: (Unbox a,
           Unbox b,
           Unbox c,
           Unbox d) => Vector (a, b, c, d) -> (Vector a,
                                               Vector b,
                                               Vector c,
                                               Vector d)
{-# INLINE unzip4 #-}
unzip4 (V_4 n_ as bs cs ds) = (as, bs, cs, ds)
#endif
#ifdef DEFINE_INSTANCES
data instance MVector s (a, b, c, d, e)
    = MV_5 {-# UNPACK #-} !Int (MVector s a)
                               (MVector s b)
                               (MVector s c)
                               (MVector s d)
                               (MVector s e)
data instance Vector (a, b, c, d, e)
    = V_5 {-# UNPACK #-} !Int (Vector a)
                              (Vector b)
                              (Vector c)
                              (Vector d)
                              (Vector e)
instance (Unbox a,
          Unbox b,
          Unbox c,
          Unbox d,
          Unbox e) => Unbox (a, b, c, d, e)
instance (Unbox a,
          Unbox b,
          Unbox c,
          Unbox d,
          Unbox e) => M.MVector MVector (a, b, c, d, e) where
  {-# INLINE basicLength  #-}
  basicLength (MV_5 n_ as bs cs ds es) = n_
  {-# INLINE basicUnsafeSlice  #-}
  basicUnsafeSlice (MV_5 n_ as bs cs ds es) i_ m_
      = MV_5 m_ (M.basicUnsafeSlice as i_ m_)
                (M.basicUnsafeSlice bs i_ m_)
                (M.basicUnsafeSlice cs i_ m_)
                (M.basicUnsafeSlice ds i_ m_)
                (M.basicUnsafeSlice es i_ m_)
  {-# INLINE basicOverlaps  #-}
  basicOverlaps (MV_5 n_1 as1 bs1 cs1 ds1 es1) (MV_5 n_2 as2
                                                         bs2
                                                         cs2
                                                         ds2
                                                         es2)
      = M.basicOverlaps as1 as2
        || M.basicOverlaps bs1 bs2
        || M.basicOverlaps cs1 cs2
        || M.basicOverlaps ds1 ds2
        || M.basicOverlaps es1 es2
  {-# INLINE basicUnsafeNew  #-}
  basicUnsafeNew n_
      = do
          as <- M.basicUnsafeNew n_
          bs <- M.basicUnsafeNew n_
          cs <- M.basicUnsafeNew n_
          ds <- M.basicUnsafeNew n_
          es <- M.basicUnsafeNew n_
          return $ MV_5 n_ as bs cs ds es
  {-# INLINE basicUnsafeNewWith  #-}
  basicUnsafeNewWith n_ (a, b, c, d, e)
      = do
          as <- M.basicUnsafeNewWith n_ a
          bs <- M.basicUnsafeNewWith n_ b
          cs <- M.basicUnsafeNewWith n_ c
          ds <- M.basicUnsafeNewWith n_ d
          es <- M.basicUnsafeNewWith n_ e
          return $ MV_5 n_ as bs cs ds es
  {-# INLINE basicUnsafeRead  #-}
  basicUnsafeRead (MV_5 n_ as bs cs ds es) i_
      = do
          a <- M.basicUnsafeRead as i_
          b <- M.basicUnsafeRead bs i_
          c <- M.basicUnsafeRead cs i_
          d <- M.basicUnsafeRead ds i_
          e <- M.basicUnsafeRead es i_
          return (a, b, c, d, e)
  {-# INLINE basicUnsafeWrite  #-}
  basicUnsafeWrite (MV_5 n_ as bs cs ds es) i_ (a, b, c, d, e)
      = do
          M.basicUnsafeWrite as i_ a
          M.basicUnsafeWrite bs i_ b
          M.basicUnsafeWrite cs i_ c
          M.basicUnsafeWrite ds i_ d
          M.basicUnsafeWrite es i_ e
  {-# INLINE basicClear  #-}
  basicClear (MV_5 n_ as bs cs ds es)
      = do
          M.basicClear as
          M.basicClear bs
          M.basicClear cs
          M.basicClear ds
          M.basicClear es
  {-# INLINE basicSet  #-}
  basicSet (MV_5 n_ as bs cs ds es) (a, b, c, d, e)
      = do
          M.basicSet as a
          M.basicSet bs b
          M.basicSet cs c
          M.basicSet ds d
          M.basicSet es e
  {-# INLINE basicUnsafeCopy  #-}
  basicUnsafeCopy (MV_5 n_1 as1 bs1 cs1 ds1 es1) (MV_5 n_2 as2
                                                           bs2
                                                           cs2
                                                           ds2
                                                           es2)
      = do
          M.basicUnsafeCopy as1 as2
          M.basicUnsafeCopy bs1 bs2
          M.basicUnsafeCopy cs1 cs2
          M.basicUnsafeCopy ds1 ds2
          M.basicUnsafeCopy es1 es2
  {-# INLINE basicUnsafeGrow  #-}
  basicUnsafeGrow (MV_5 n_ as bs cs ds es) m_
      = do
          M.basicUnsafeGrow as m_
          M.basicUnsafeGrow bs m_
          M.basicUnsafeGrow cs m_
          M.basicUnsafeGrow ds m_
          M.basicUnsafeGrow es m_
          return $ MV_5 (m_+n_) as bs cs ds es
instance (Unbox a,
          Unbox b,
          Unbox c,
          Unbox d,
          Unbox e) => G.Vector Vector (a, b, c, d, e) where
  {-# INLINE unsafeFreeze  #-}
  unsafeFreeze (MV_5 n_ as bs cs ds es)
      = do
          as' <- G.unsafeFreeze as
          bs' <- G.unsafeFreeze bs
          cs' <- G.unsafeFreeze cs
          ds' <- G.unsafeFreeze ds
          es' <- G.unsafeFreeze es
          return $ V_5 n_ as' bs' cs' ds' es'
  {-# INLINE basicLength  #-}
  basicLength (V_5 n_ as bs cs ds es) = n_
  {-# INLINE basicUnsafeSlice  #-}
  basicUnsafeSlice (V_5 n_ as bs cs ds es) i_ m_
      = V_5 m_ (G.basicUnsafeSlice as i_ m_)
               (G.basicUnsafeSlice bs i_ m_)
               (G.basicUnsafeSlice cs i_ m_)
               (G.basicUnsafeSlice ds i_ m_)
               (G.basicUnsafeSlice es i_ m_)
  {-# INLINE basicUnsafeIndexM  #-}
  basicUnsafeIndexM (V_5 n_ as bs cs ds es) i_
      = do
          a <- G.basicUnsafeIndexM as i_
          b <- G.basicUnsafeIndexM bs i_
          c <- G.basicUnsafeIndexM cs i_
          d <- G.basicUnsafeIndexM ds i_
          e <- G.basicUnsafeIndexM es i_
          return (a, b, c, d, e)
#endif
#ifdef DEFINE_MUTABLE
zip5 :: (Unbox a,
         Unbox b,
         Unbox c,
         Unbox d,
         Unbox e) => MVector s a ->
                     MVector s b ->
                     MVector s c ->
                     MVector s d ->
                     MVector s e -> MVector s (a, b, c, d, e)
{-# INLINE zip5 #-}
zip5 as bs cs ds es = MV_5 len (unsafeSlice as 0 len)
                               (unsafeSlice bs 0 len)
                               (unsafeSlice cs 0 len)
                               (unsafeSlice ds 0 len)
                               (unsafeSlice es 0 len)
  where
    len = length as `min`
          length bs `min`
          length cs `min`
          length ds `min`
          length es
unzip5 :: (Unbox a,
           Unbox b,
           Unbox c,
           Unbox d,
           Unbox e) => MVector s (a, b, c, d, e) -> (MVector s a,
                                                     MVector s b,
                                                     MVector s c,
                                                     MVector s d,
                                                     MVector s e)
{-# INLINE unzip5 #-}
unzip5 (MV_5 n_ as bs cs ds es) = (as, bs, cs, ds, es)
#endif
#ifdef DEFINE_IMMUTABLE
zip5 :: (Unbox a,
         Unbox b,
         Unbox c,
         Unbox d,
         Unbox e) => Vector a ->
                     Vector b ->
                     Vector c ->
                     Vector d ->
                     Vector e -> Vector (a, b, c, d, e)
{-# INLINE zip5 #-}
zip5 as bs cs ds es = V_5 len (unsafeSlice as 0 len)
                              (unsafeSlice bs 0 len)
                              (unsafeSlice cs 0 len)
                              (unsafeSlice ds 0 len)
                              (unsafeSlice es 0 len)
  where
    len = length as `min`
          length bs `min`
          length cs `min`
          length ds `min`
          length es
unzip5 :: (Unbox a,
           Unbox b,
           Unbox c,
           Unbox d,
           Unbox e) => Vector (a, b, c, d, e) -> (Vector a,
                                                  Vector b,
                                                  Vector c,
                                                  Vector d,
                                                  Vector e)
{-# INLINE unzip5 #-}
unzip5 (V_5 n_ as bs cs ds es) = (as, bs, cs, ds, es)
#endif
#ifdef DEFINE_INSTANCES
data instance MVector s (a, b, c, d, e, f)
    = MV_6 {-# UNPACK #-} !Int (MVector s a)
                               (MVector s b)
                               (MVector s c)
                               (MVector s d)
                               (MVector s e)
                               (MVector s f)
data instance Vector (a, b, c, d, e, f)
    = V_6 {-# UNPACK #-} !Int (Vector a)
                              (Vector b)
                              (Vector c)
                              (Vector d)
                              (Vector e)
                              (Vector f)
instance (Unbox a,
          Unbox b,
          Unbox c,
          Unbox d,
          Unbox e,
          Unbox f) => Unbox (a, b, c, d, e, f)
instance (Unbox a,
          Unbox b,
          Unbox c,
          Unbox d,
          Unbox e,
          Unbox f) => M.MVector MVector (a, b, c, d, e, f) where
  {-# INLINE basicLength  #-}
  basicLength (MV_6 n_ as bs cs ds es fs) = n_
  {-# INLINE basicUnsafeSlice  #-}
  basicUnsafeSlice (MV_6 n_ as bs cs ds es fs) i_ m_
      = MV_6 m_ (M.basicUnsafeSlice as i_ m_)
                (M.basicUnsafeSlice bs i_ m_)
                (M.basicUnsafeSlice cs i_ m_)
                (M.basicUnsafeSlice ds i_ m_)
                (M.basicUnsafeSlice es i_ m_)
                (M.basicUnsafeSlice fs i_ m_)
  {-# INLINE basicOverlaps  #-}
  basicOverlaps (MV_6 n_1 as1 bs1 cs1 ds1 es1 fs1) (MV_6 n_2 as2
                                                             bs2
                                                             cs2
                                                             ds2
                                                             es2
                                                             fs2)
      = M.basicOverlaps as1 as2
        || M.basicOverlaps bs1 bs2
        || M.basicOverlaps cs1 cs2
        || M.basicOverlaps ds1 ds2
        || M.basicOverlaps es1 es2
        || M.basicOverlaps fs1 fs2
  {-# INLINE basicUnsafeNew  #-}
  basicUnsafeNew n_
      = do
          as <- M.basicUnsafeNew n_
          bs <- M.basicUnsafeNew n_
          cs <- M.basicUnsafeNew n_
          ds <- M.basicUnsafeNew n_
          es <- M.basicUnsafeNew n_
          fs <- M.basicUnsafeNew n_
          return $ MV_6 n_ as bs cs ds es fs
  {-# INLINE basicUnsafeNewWith  #-}
  basicUnsafeNewWith n_ (a, b, c, d, e, f)
      = do
          as <- M.basicUnsafeNewWith n_ a
          bs <- M.basicUnsafeNewWith n_ b
          cs <- M.basicUnsafeNewWith n_ c
          ds <- M.basicUnsafeNewWith n_ d
          es <- M.basicUnsafeNewWith n_ e
          fs <- M.basicUnsafeNewWith n_ f
          return $ MV_6 n_ as bs cs ds es fs
  {-# INLINE basicUnsafeRead  #-}
  basicUnsafeRead (MV_6 n_ as bs cs ds es fs) i_
      = do
          a <- M.basicUnsafeRead as i_
          b <- M.basicUnsafeRead bs i_
          c <- M.basicUnsafeRead cs i_
          d <- M.basicUnsafeRead ds i_
          e <- M.basicUnsafeRead es i_
          f <- M.basicUnsafeRead fs i_
          return (a, b, c, d, e, f)
  {-# INLINE basicUnsafeWrite  #-}
  basicUnsafeWrite (MV_6 n_ as bs cs ds es fs) i_ (a, b, c, d, e, f)
      = do
          M.basicUnsafeWrite as i_ a
          M.basicUnsafeWrite bs i_ b
          M.basicUnsafeWrite cs i_ c
          M.basicUnsafeWrite ds i_ d
          M.basicUnsafeWrite es i_ e
          M.basicUnsafeWrite fs i_ f
  {-# INLINE basicClear  #-}
  basicClear (MV_6 n_ as bs cs ds es fs)
      = do
          M.basicClear as
          M.basicClear bs
          M.basicClear cs
          M.basicClear ds
          M.basicClear es
          M.basicClear fs
  {-# INLINE basicSet  #-}
  basicSet (MV_6 n_ as bs cs ds es fs) (a, b, c, d, e, f)
      = do
          M.basicSet as a
          M.basicSet bs b
          M.basicSet cs c
          M.basicSet ds d
          M.basicSet es e
          M.basicSet fs f
  {-# INLINE basicUnsafeCopy  #-}
  basicUnsafeCopy (MV_6 n_1 as1 bs1 cs1 ds1 es1 fs1) (MV_6 n_2 as2
                                                               bs2
                                                               cs2
                                                               ds2
                                                               es2
                                                               fs2)
      = do
          M.basicUnsafeCopy as1 as2
          M.basicUnsafeCopy bs1 bs2
          M.basicUnsafeCopy cs1 cs2
          M.basicUnsafeCopy ds1 ds2
          M.basicUnsafeCopy es1 es2
          M.basicUnsafeCopy fs1 fs2
  {-# INLINE basicUnsafeGrow  #-}
  basicUnsafeGrow (MV_6 n_ as bs cs ds es fs) m_
      = do
          M.basicUnsafeGrow as m_
          M.basicUnsafeGrow bs m_
          M.basicUnsafeGrow cs m_
          M.basicUnsafeGrow ds m_
          M.basicUnsafeGrow es m_
          M.basicUnsafeGrow fs m_
          return $ MV_6 (m_+n_) as bs cs ds es fs
instance (Unbox a,
          Unbox b,
          Unbox c,
          Unbox d,
          Unbox e,
          Unbox f) => G.Vector Vector (a, b, c, d, e, f) where
  {-# INLINE unsafeFreeze  #-}
  unsafeFreeze (MV_6 n_ as bs cs ds es fs)
      = do
          as' <- G.unsafeFreeze as
          bs' <- G.unsafeFreeze bs
          cs' <- G.unsafeFreeze cs
          ds' <- G.unsafeFreeze ds
          es' <- G.unsafeFreeze es
          fs' <- G.unsafeFreeze fs
          return $ V_6 n_ as' bs' cs' ds' es' fs'
  {-# INLINE basicLength  #-}
  basicLength (V_6 n_ as bs cs ds es fs) = n_
  {-# INLINE basicUnsafeSlice  #-}
  basicUnsafeSlice (V_6 n_ as bs cs ds es fs) i_ m_
      = V_6 m_ (G.basicUnsafeSlice as i_ m_)
               (G.basicUnsafeSlice bs i_ m_)
               (G.basicUnsafeSlice cs i_ m_)
               (G.basicUnsafeSlice ds i_ m_)
               (G.basicUnsafeSlice es i_ m_)
               (G.basicUnsafeSlice fs i_ m_)
  {-# INLINE basicUnsafeIndexM  #-}
  basicUnsafeIndexM (V_6 n_ as bs cs ds es fs) i_
      = do
          a <- G.basicUnsafeIndexM as i_
          b <- G.basicUnsafeIndexM bs i_
          c <- G.basicUnsafeIndexM cs i_
          d <- G.basicUnsafeIndexM ds i_
          e <- G.basicUnsafeIndexM es i_
          f <- G.basicUnsafeIndexM fs i_
          return (a, b, c, d, e, f)
#endif
#ifdef DEFINE_MUTABLE
zip6 :: (Unbox a,
         Unbox b,
         Unbox c,
         Unbox d,
         Unbox e,
         Unbox f) => MVector s a ->
                     MVector s b ->
                     MVector s c ->
                     MVector s d ->
                     MVector s e ->
                     MVector s f -> MVector s (a, b, c, d, e, f)
{-# INLINE zip6 #-}
zip6 as bs cs ds es fs = MV_6 len (unsafeSlice as 0 len)
                                  (unsafeSlice bs 0 len)
                                  (unsafeSlice cs 0 len)
                                  (unsafeSlice ds 0 len)
                                  (unsafeSlice es 0 len)
                                  (unsafeSlice fs 0 len)
  where
    len = length as `min`
          length bs `min`
          length cs `min`
          length ds `min`
          length es `min`
          length fs
unzip6 :: (Unbox a,
           Unbox b,
           Unbox c,
           Unbox d,
           Unbox e,
           Unbox f) => MVector s (a, b, c, d, e, f) -> (MVector s a,
                                                        MVector s b,
                                                        MVector s c,
                                                        MVector s d,
                                                        MVector s e,
                                                        MVector s f)
{-# INLINE unzip6 #-}
unzip6 (MV_6 n_ as bs cs ds es fs) = (as, bs, cs, ds, es, fs)
#endif
#ifdef DEFINE_IMMUTABLE
zip6 :: (Unbox a,
         Unbox b,
         Unbox c,
         Unbox d,
         Unbox e,
         Unbox f) => Vector a ->
                     Vector b ->
                     Vector c ->
                     Vector d ->
                     Vector e ->
                     Vector f -> Vector (a, b, c, d, e, f)
{-# INLINE zip6 #-}
zip6 as bs cs ds es fs = V_6 len (unsafeSlice as 0 len)
                                 (unsafeSlice bs 0 len)
                                 (unsafeSlice cs 0 len)
                                 (unsafeSlice ds 0 len)
                                 (unsafeSlice es 0 len)
                                 (unsafeSlice fs 0 len)
  where
    len = length as `min`
          length bs `min`
          length cs `min`
          length ds `min`
          length es `min`
          length fs
unzip6 :: (Unbox a,
           Unbox b,
           Unbox c,
           Unbox d,
           Unbox e,
           Unbox f) => Vector (a, b, c, d, e, f) -> (Vector a,
                                                     Vector b,
                                                     Vector c,
                                                     Vector d,
                                                     Vector e,
                                                     Vector f)
{-# INLINE unzip6 #-}
unzip6 (V_6 n_ as bs cs ds es fs) = (as, bs, cs, ds, es, fs)
#endif
#ifdef DEFINE_INSTANCES
data instance MVector s (a, b, c, d, e, f, g)
    = MV_7 {-# UNPACK #-} !Int (MVector s a)
                               (MVector s b)
                               (MVector s c)
                               (MVector s d)
                               (MVector s e)
                               (MVector s f)
                               (MVector s g)
data instance Vector (a, b, c, d, e, f, g)
    = V_7 {-# UNPACK #-} !Int (Vector a)
                              (Vector b)
                              (Vector c)
                              (Vector d)
                              (Vector e)
                              (Vector f)
                              (Vector g)
instance (Unbox a,
          Unbox b,
          Unbox c,
          Unbox d,
          Unbox e,
          Unbox f,
          Unbox g) => Unbox (a, b, c, d, e, f, g)
instance (Unbox a,
          Unbox b,
          Unbox c,
          Unbox d,
          Unbox e,
          Unbox f,
          Unbox g) => M.MVector MVector (a, b, c, d, e, f, g) where
  {-# INLINE basicLength  #-}
  basicLength (MV_7 n_ as bs cs ds es fs gs) = n_
  {-# INLINE basicUnsafeSlice  #-}
  basicUnsafeSlice (MV_7 n_ as bs cs ds es fs gs) i_ m_
      = MV_7 m_ (M.basicUnsafeSlice as i_ m_)
                (M.basicUnsafeSlice bs i_ m_)
                (M.basicUnsafeSlice cs i_ m_)
                (M.basicUnsafeSlice ds i_ m_)
                (M.basicUnsafeSlice es i_ m_)
                (M.basicUnsafeSlice fs i_ m_)
                (M.basicUnsafeSlice gs i_ m_)
  {-# INLINE basicOverlaps  #-}
  basicOverlaps (MV_7 n_1 as1 bs1 cs1 ds1 es1 fs1 gs1) (MV_7 n_2 as2
                                                                 bs2
                                                                 cs2
                                                                 ds2
                                                                 es2
                                                                 fs2
                                                                 gs2)
      = M.basicOverlaps as1 as2
        || M.basicOverlaps bs1 bs2
        || M.basicOverlaps cs1 cs2
        || M.basicOverlaps ds1 ds2
        || M.basicOverlaps es1 es2
        || M.basicOverlaps fs1 fs2
        || M.basicOverlaps gs1 gs2
  {-# INLINE basicUnsafeNew  #-}
  basicUnsafeNew n_
      = do
          as <- M.basicUnsafeNew n_
          bs <- M.basicUnsafeNew n_
          cs <- M.basicUnsafeNew n_
          ds <- M.basicUnsafeNew n_
          es <- M.basicUnsafeNew n_
          fs <- M.basicUnsafeNew n_
          gs <- M.basicUnsafeNew n_
          return $ MV_7 n_ as bs cs ds es fs gs
  {-# INLINE basicUnsafeNewWith  #-}
  basicUnsafeNewWith n_ (a, b, c, d, e, f, g)
      = do
          as <- M.basicUnsafeNewWith n_ a
          bs <- M.basicUnsafeNewWith n_ b
          cs <- M.basicUnsafeNewWith n_ c
          ds <- M.basicUnsafeNewWith n_ d
          es <- M.basicUnsafeNewWith n_ e
          fs <- M.basicUnsafeNewWith n_ f
          gs <- M.basicUnsafeNewWith n_ g
          return $ MV_7 n_ as bs cs ds es fs gs
  {-# INLINE basicUnsafeRead  #-}
  basicUnsafeRead (MV_7 n_ as bs cs ds es fs gs) i_
      = do
          a <- M.basicUnsafeRead as i_
          b <- M.basicUnsafeRead bs i_
          c <- M.basicUnsafeRead cs i_
          d <- M.basicUnsafeRead ds i_
          e <- M.basicUnsafeRead es i_
          f <- M.basicUnsafeRead fs i_
          g <- M.basicUnsafeRead gs i_
          return (a, b, c, d, e, f, g)
  {-# INLINE basicUnsafeWrite  #-}
  basicUnsafeWrite (MV_7 n_ as
                            bs
                            cs
                            ds
                            es
                            fs
                            gs) i_ (a, b, c, d, e, f, g)
      = do
          M.basicUnsafeWrite as i_ a
          M.basicUnsafeWrite bs i_ b
          M.basicUnsafeWrite cs i_ c
          M.basicUnsafeWrite ds i_ d
          M.basicUnsafeWrite es i_ e
          M.basicUnsafeWrite fs i_ f
          M.basicUnsafeWrite gs i_ g
  {-# INLINE basicClear  #-}
  basicClear (MV_7 n_ as bs cs ds es fs gs)
      = do
          M.basicClear as
          M.basicClear bs
          M.basicClear cs
          M.basicClear ds
          M.basicClear es
          M.basicClear fs
          M.basicClear gs
  {-# INLINE basicSet  #-}
  basicSet (MV_7 n_ as bs cs ds es fs gs) (a, b, c, d, e, f, g)
      = do
          M.basicSet as a
          M.basicSet bs b
          M.basicSet cs c
          M.basicSet ds d
          M.basicSet es e
          M.basicSet fs f
          M.basicSet gs g
  {-# INLINE basicUnsafeCopy  #-}
  basicUnsafeCopy (MV_7 n_1 as1
                            bs1
                            cs1
                            ds1
                            es1
                            fs1
                            gs1) (MV_7 n_2 as2 bs2 cs2 ds2 es2 fs2 gs2)
      = do
          M.basicUnsafeCopy as1 as2
          M.basicUnsafeCopy bs1 bs2
          M.basicUnsafeCopy cs1 cs2
          M.basicUnsafeCopy ds1 ds2
          M.basicUnsafeCopy es1 es2
          M.basicUnsafeCopy fs1 fs2
          M.basicUnsafeCopy gs1 gs2
  {-# INLINE basicUnsafeGrow  #-}
  basicUnsafeGrow (MV_7 n_ as bs cs ds es fs gs) m_
      = do
          M.basicUnsafeGrow as m_
          M.basicUnsafeGrow bs m_
          M.basicUnsafeGrow cs m_
          M.basicUnsafeGrow ds m_
          M.basicUnsafeGrow es m_
          M.basicUnsafeGrow fs m_
          M.basicUnsafeGrow gs m_
          return $ MV_7 (m_+n_) as bs cs ds es fs gs
instance (Unbox a,
          Unbox b,
          Unbox c,
          Unbox d,
          Unbox e,
          Unbox f,
          Unbox g) => G.Vector Vector (a, b, c, d, e, f, g) where
  {-# INLINE unsafeFreeze  #-}
  unsafeFreeze (MV_7 n_ as bs cs ds es fs gs)
      = do
          as' <- G.unsafeFreeze as
          bs' <- G.unsafeFreeze bs
          cs' <- G.unsafeFreeze cs
          ds' <- G.unsafeFreeze ds
          es' <- G.unsafeFreeze es
          fs' <- G.unsafeFreeze fs
          gs' <- G.unsafeFreeze gs
          return $ V_7 n_ as' bs' cs' ds' es' fs' gs'
  {-# INLINE basicLength  #-}
  basicLength (V_7 n_ as bs cs ds es fs gs) = n_
  {-# INLINE basicUnsafeSlice  #-}
  basicUnsafeSlice (V_7 n_ as bs cs ds es fs gs) i_ m_
      = V_7 m_ (G.basicUnsafeSlice as i_ m_)
               (G.basicUnsafeSlice bs i_ m_)
               (G.basicUnsafeSlice cs i_ m_)
               (G.basicUnsafeSlice ds i_ m_)
               (G.basicUnsafeSlice es i_ m_)
               (G.basicUnsafeSlice fs i_ m_)
               (G.basicUnsafeSlice gs i_ m_)
  {-# INLINE basicUnsafeIndexM  #-}
  basicUnsafeIndexM (V_7 n_ as bs cs ds es fs gs) i_
      = do
          a <- G.basicUnsafeIndexM as i_
          b <- G.basicUnsafeIndexM bs i_
          c <- G.basicUnsafeIndexM cs i_
          d <- G.basicUnsafeIndexM ds i_
          e <- G.basicUnsafeIndexM es i_
          f <- G.basicUnsafeIndexM fs i_
          g <- G.basicUnsafeIndexM gs i_
          return (a, b, c, d, e, f, g)
#endif
#ifdef DEFINE_MUTABLE
zip7 :: (Unbox a,
         Unbox b,
         Unbox c,
         Unbox d,
         Unbox e,
         Unbox f,
         Unbox g) => MVector s a ->
                     MVector s b ->
                     MVector s c ->
                     MVector s d ->
                     MVector s e ->
                     MVector s f ->
                     MVector s g -> MVector s (a, b, c, d, e, f, g)
{-# INLINE zip7 #-}
zip7 as bs cs ds es fs gs = MV_7 len (unsafeSlice as 0 len)
                                     (unsafeSlice bs 0 len)
                                     (unsafeSlice cs 0 len)
                                     (unsafeSlice ds 0 len)
                                     (unsafeSlice es 0 len)
                                     (unsafeSlice fs 0 len)
                                     (unsafeSlice gs 0 len)
  where
    len = length as `min`
          length bs `min`
          length cs `min`
          length ds `min`
          length es `min`
          length fs `min`
          length gs
unzip7 :: (Unbox a,
           Unbox b,
           Unbox c,
           Unbox d,
           Unbox e,
           Unbox f,
           Unbox g) => MVector s (a, b, c, d, e, f, g) -> (MVector s a,
                                                           MVector s b,
                                                           MVector s c,
                                                           MVector s d,
                                                           MVector s e,
                                                           MVector s f,
                                                           MVector s g)
{-# INLINE unzip7 #-}
unzip7 (MV_7 n_ as bs cs ds es fs gs) = (as,
                                         bs,
                                         cs,
                                         ds,
                                         es,
                                         fs,
                                         gs)
#endif
#ifdef DEFINE_IMMUTABLE
zip7 :: (Unbox a,
         Unbox b,
         Unbox c,
         Unbox d,
         Unbox e,
         Unbox f,
         Unbox g) => Vector a ->
                     Vector b ->
                     Vector c ->
                     Vector d ->
                     Vector e ->
                     Vector f ->
                     Vector g -> Vector (a, b, c, d, e, f, g)
{-# INLINE zip7 #-}
zip7 as bs cs ds es fs gs = V_7 len (unsafeSlice as 0 len)
                                    (unsafeSlice bs 0 len)
                                    (unsafeSlice cs 0 len)
                                    (unsafeSlice ds 0 len)
                                    (unsafeSlice es 0 len)
                                    (unsafeSlice fs 0 len)
                                    (unsafeSlice gs 0 len)
  where
    len = length as `min`
          length bs `min`
          length cs `min`
          length ds `min`
          length es `min`
          length fs `min`
          length gs
unzip7 :: (Unbox a,
           Unbox b,
           Unbox c,
           Unbox d,
           Unbox e,
           Unbox f,
           Unbox g) => Vector (a, b, c, d, e, f, g) -> (Vector a,
                                                        Vector b,
                                                        Vector c,
                                                        Vector d,
                                                        Vector e,
                                                        Vector f,
                                                        Vector g)
{-# INLINE unzip7 #-}
unzip7 (V_7 n_ as bs cs ds es fs gs) = (as, bs, cs, ds, es, fs, gs)
#endif
#ifdef DEFINE_INSTANCES
data instance MVector s (a, b, c, d, e, f, g, h)
    = MV_8 {-# UNPACK #-} !Int (MVector s a)
                               (MVector s b)
                               (MVector s c)
                               (MVector s d)
                               (MVector s e)
                               (MVector s f)
                               (MVector s g)
                               (MVector s h)
data instance Vector (a, b, c, d, e, f, g, h)
    = V_8 {-# UNPACK #-} !Int (Vector a)
                              (Vector b)
                              (Vector c)
                              (Vector d)
                              (Vector e)
                              (Vector f)
                              (Vector g)
                              (Vector h)
instance (Unbox a,
          Unbox b,
          Unbox c,
          Unbox d,
          Unbox e,
          Unbox f,
          Unbox g,
          Unbox h) => Unbox (a, b, c, d, e, f, g, h)
instance (Unbox a,
          Unbox b,
          Unbox c,
          Unbox d,
          Unbox e,
          Unbox f,
          Unbox g,
          Unbox h) => M.MVector MVector (a, b, c, d, e, f, g, h) where
  {-# INLINE basicLength  #-}
  basicLength (MV_8 n_ as bs cs ds es fs gs hs) = n_
  {-# INLINE basicUnsafeSlice  #-}
  basicUnsafeSlice (MV_8 n_ as bs cs ds es fs gs hs) i_ m_
      = MV_8 m_ (M.basicUnsafeSlice as i_ m_)
                (M.basicUnsafeSlice bs i_ m_)
                (M.basicUnsafeSlice cs i_ m_)
                (M.basicUnsafeSlice ds i_ m_)
                (M.basicUnsafeSlice es i_ m_)
                (M.basicUnsafeSlice fs i_ m_)
                (M.basicUnsafeSlice gs i_ m_)
                (M.basicUnsafeSlice hs i_ m_)
  {-# INLINE basicOverlaps  #-}
  basicOverlaps (MV_8 n_1 as1
                          bs1
                          cs1
                          ds1
                          es1
                          fs1
                          gs1
                          hs1) (MV_8 n_2 as2 bs2 cs2 ds2 es2 fs2 gs2 hs2)
      = M.basicOverlaps as1 as2
        || M.basicOverlaps bs1 bs2
        || M.basicOverlaps cs1 cs2
        || M.basicOverlaps ds1 ds2
        || M.basicOverlaps es1 es2
        || M.basicOverlaps fs1 fs2
        || M.basicOverlaps gs1 gs2
        || M.basicOverlaps hs1 hs2
  {-# INLINE basicUnsafeNew  #-}
  basicUnsafeNew n_
      = do
          as <- M.basicUnsafeNew n_
          bs <- M.basicUnsafeNew n_
          cs <- M.basicUnsafeNew n_
          ds <- M.basicUnsafeNew n_
          es <- M.basicUnsafeNew n_
          fs <- M.basicUnsafeNew n_
          gs <- M.basicUnsafeNew n_
          hs <- M.basicUnsafeNew n_
          return $ MV_8 n_ as bs cs ds es fs gs hs
  {-# INLINE basicUnsafeNewWith  #-}
  basicUnsafeNewWith n_ (a, b, c, d, e, f, g, h)
      = do
          as <- M.basicUnsafeNewWith n_ a
          bs <- M.basicUnsafeNewWith n_ b
          cs <- M.basicUnsafeNewWith n_ c
          ds <- M.basicUnsafeNewWith n_ d
          es <- M.basicUnsafeNewWith n_ e
          fs <- M.basicUnsafeNewWith n_ f
          gs <- M.basicUnsafeNewWith n_ g
          hs <- M.basicUnsafeNewWith n_ h
          return $ MV_8 n_ as bs cs ds es fs gs hs
  {-# INLINE basicUnsafeRead  #-}
  basicUnsafeRead (MV_8 n_ as bs cs ds es fs gs hs) i_
      = do
          a <- M.basicUnsafeRead as i_
          b <- M.basicUnsafeRead bs i_
          c <- M.basicUnsafeRead cs i_
          d <- M.basicUnsafeRead ds i_
          e <- M.basicUnsafeRead es i_
          f <- M.basicUnsafeRead fs i_
          g <- M.basicUnsafeRead gs i_
          h <- M.basicUnsafeRead hs i_
          return (a, b, c, d, e, f, g, h)
  {-# INLINE basicUnsafeWrite  #-}
  basicUnsafeWrite (MV_8 n_ as
                            bs
                            cs
                            ds
                            es
                            fs
                            gs
                            hs) i_ (a, b, c, d, e, f, g, h)
      = do
          M.basicUnsafeWrite as i_ a
          M.basicUnsafeWrite bs i_ b
          M.basicUnsafeWrite cs i_ c
          M.basicUnsafeWrite ds i_ d
          M.basicUnsafeWrite es i_ e
          M.basicUnsafeWrite fs i_ f
          M.basicUnsafeWrite gs i_ g
          M.basicUnsafeWrite hs i_ h
  {-# INLINE basicClear  #-}
  basicClear (MV_8 n_ as bs cs ds es fs gs hs)
      = do
          M.basicClear as
          M.basicClear bs
          M.basicClear cs
          M.basicClear ds
          M.basicClear es
          M.basicClear fs
          M.basicClear gs
          M.basicClear hs
  {-# INLINE basicSet  #-}
  basicSet (MV_8 n_ as bs cs ds es fs gs hs) (a, b, c, d, e, f, g, h)
      = do
          M.basicSet as a
          M.basicSet bs b
          M.basicSet cs c
          M.basicSet ds d
          M.basicSet es e
          M.basicSet fs f
          M.basicSet gs g
          M.basicSet hs h
  {-# INLINE basicUnsafeCopy  #-}
  basicUnsafeCopy (MV_8 n_1 as1
                            bs1
                            cs1
                            ds1
                            es1
                            fs1
                            gs1
                            hs1) (MV_8 n_2 as2 bs2 cs2 ds2 es2 fs2 gs2 hs2)
      = do
          M.basicUnsafeCopy as1 as2
          M.basicUnsafeCopy bs1 bs2
          M.basicUnsafeCopy cs1 cs2
          M.basicUnsafeCopy ds1 ds2
          M.basicUnsafeCopy es1 es2
          M.basicUnsafeCopy fs1 fs2
          M.basicUnsafeCopy gs1 gs2
          M.basicUnsafeCopy hs1 hs2
  {-# INLINE basicUnsafeGrow  #-}
  basicUnsafeGrow (MV_8 n_ as bs cs ds es fs gs hs) m_
      = do
          M.basicUnsafeGrow as m_
          M.basicUnsafeGrow bs m_
          M.basicUnsafeGrow cs m_
          M.basicUnsafeGrow ds m_
          M.basicUnsafeGrow es m_
          M.basicUnsafeGrow fs m_
          M.basicUnsafeGrow gs m_
          M.basicUnsafeGrow hs m_
          return $ MV_8 (m_+n_) as bs cs ds es fs gs hs
instance (Unbox a,
          Unbox b,
          Unbox c,
          Unbox d,
          Unbox e,
          Unbox f,
          Unbox g,
          Unbox h) => G.Vector Vector (a, b, c, d, e, f, g, h) where
  {-# INLINE unsafeFreeze  #-}
  unsafeFreeze (MV_8 n_ as bs cs ds es fs gs hs)
      = do
          as' <- G.unsafeFreeze as
          bs' <- G.unsafeFreeze bs
          cs' <- G.unsafeFreeze cs
          ds' <- G.unsafeFreeze ds
          es' <- G.unsafeFreeze es
          fs' <- G.unsafeFreeze fs
          gs' <- G.unsafeFreeze gs
          hs' <- G.unsafeFreeze hs
          return $ V_8 n_ as' bs' cs' ds' es' fs' gs' hs'
  {-# INLINE basicLength  #-}
  basicLength (V_8 n_ as bs cs ds es fs gs hs) = n_
  {-# INLINE basicUnsafeSlice  #-}
  basicUnsafeSlice (V_8 n_ as bs cs ds es fs gs hs) i_ m_
      = V_8 m_ (G.basicUnsafeSlice as i_ m_)
               (G.basicUnsafeSlice bs i_ m_)
               (G.basicUnsafeSlice cs i_ m_)
               (G.basicUnsafeSlice ds i_ m_)
               (G.basicUnsafeSlice es i_ m_)
               (G.basicUnsafeSlice fs i_ m_)
               (G.basicUnsafeSlice gs i_ m_)
               (G.basicUnsafeSlice hs i_ m_)
  {-# INLINE basicUnsafeIndexM  #-}
  basicUnsafeIndexM (V_8 n_ as bs cs ds es fs gs hs) i_
      = do
          a <- G.basicUnsafeIndexM as i_
          b <- G.basicUnsafeIndexM bs i_
          c <- G.basicUnsafeIndexM cs i_
          d <- G.basicUnsafeIndexM ds i_
          e <- G.basicUnsafeIndexM es i_
          f <- G.basicUnsafeIndexM fs i_
          g <- G.basicUnsafeIndexM gs i_
          h <- G.basicUnsafeIndexM hs i_
          return (a, b, c, d, e, f, g, h)
#endif
#ifdef DEFINE_MUTABLE
zip8 :: (Unbox a,
         Unbox b,
         Unbox c,
         Unbox d,
         Unbox e,
         Unbox f,
         Unbox g,
         Unbox h) => MVector s a ->
                     MVector s b ->
                     MVector s c ->
                     MVector s d ->
                     MVector s e ->
                     MVector s f ->
                     MVector s g ->
                     MVector s h -> MVector s (a, b, c, d, e, f, g, h)
{-# INLINE zip8 #-}
zip8 as bs cs ds es fs gs hs = MV_8 len (unsafeSlice as 0 len)
                                        (unsafeSlice bs 0 len)
                                        (unsafeSlice cs 0 len)
                                        (unsafeSlice ds 0 len)
                                        (unsafeSlice es 0 len)
                                        (unsafeSlice fs 0 len)
                                        (unsafeSlice gs 0 len)
                                        (unsafeSlice hs 0 len)
  where
    len = length as `min`
          length bs `min`
          length cs `min`
          length ds `min`
          length es `min`
          length fs `min`
          length gs `min`
          length hs
unzip8 :: (Unbox a,
           Unbox b,
           Unbox c,
           Unbox d,
           Unbox e,
           Unbox f,
           Unbox g,
           Unbox h) => MVector s (a, b, c, d, e, f, g, h) -> (MVector s a,
                                                              MVector s b,
                                                              MVector s c,
                                                              MVector s d,
                                                              MVector s e,
                                                              MVector s f,
                                                              MVector s g,
                                                              MVector s h)
{-# INLINE unzip8 #-}
unzip8 (MV_8 n_ as bs cs ds es fs gs hs) = (as,
                                            bs,
                                            cs,
                                            ds,
                                            es,
                                            fs,
                                            gs,
                                            hs)
#endif
#ifdef DEFINE_IMMUTABLE
zip8 :: (Unbox a,
         Unbox b,
         Unbox c,
         Unbox d,
         Unbox e,
         Unbox f,
         Unbox g,
         Unbox h) => Vector a ->
                     Vector b ->
                     Vector c ->
                     Vector d ->
                     Vector e ->
                     Vector f ->
                     Vector g ->
                     Vector h -> Vector (a, b, c, d, e, f, g, h)
{-# INLINE zip8 #-}
zip8 as bs cs ds es fs gs hs = V_8 len (unsafeSlice as 0 len)
                                       (unsafeSlice bs 0 len)
                                       (unsafeSlice cs 0 len)
                                       (unsafeSlice ds 0 len)
                                       (unsafeSlice es 0 len)
                                       (unsafeSlice fs 0 len)
                                       (unsafeSlice gs 0 len)
                                       (unsafeSlice hs 0 len)
  where
    len = length as `min`
          length bs `min`
          length cs `min`
          length ds `min`
          length es `min`
          length fs `min`
          length gs `min`
          length hs
unzip8 :: (Unbox a,
           Unbox b,
           Unbox c,
           Unbox d,
           Unbox e,
           Unbox f,
           Unbox g,
           Unbox h) => Vector (a, b, c, d, e, f, g, h) -> (Vector a,
                                                           Vector b,
                                                           Vector c,
                                                           Vector d,
                                                           Vector e,
                                                           Vector f,
                                                           Vector g,
                                                           Vector h)
{-# INLINE unzip8 #-}
unzip8 (V_8 n_ as bs cs ds es fs gs hs) = (as,
                                           bs,
                                           cs,
                                           ds,
                                           es,
                                           fs,
                                           gs,
                                           hs)
#endif
#ifdef DEFINE_INSTANCES
data instance MVector s (a, b, c, d, e, f, g, h, i)
    = MV_9 {-# UNPACK #-} !Int (MVector s a)
                               (MVector s b)
                               (MVector s c)
                               (MVector s d)
                               (MVector s e)
                               (MVector s f)
                               (MVector s g)
                               (MVector s h)
                               (MVector s i)
data instance Vector (a, b, c, d, e, f, g, h, i)
    = V_9 {-# UNPACK #-} !Int (Vector a)
                              (Vector b)
                              (Vector c)
                              (Vector d)
                              (Vector e)
                              (Vector f)
                              (Vector g)
                              (Vector h)
                              (Vector i)
instance (Unbox a,
          Unbox b,
          Unbox c,
          Unbox d,
          Unbox e,
          Unbox f,
          Unbox g,
          Unbox h,
          Unbox i) => Unbox (a, b, c, d, e, f, g, h, i)
instance (Unbox a,
          Unbox b,
          Unbox c,
          Unbox d,
          Unbox e,
          Unbox f,
          Unbox g,
          Unbox h,
          Unbox i) => M.MVector MVector (a, b, c, d, e, f, g, h, i) where
  {-# INLINE basicLength  #-}
  basicLength (MV_9 n_ as bs cs ds es fs gs hs is) = n_
  {-# INLINE basicUnsafeSlice  #-}
  basicUnsafeSlice (MV_9 n_ as bs cs ds es fs gs hs is) i_ m_
      = MV_9 m_ (M.basicUnsafeSlice as i_ m_)
                (M.basicUnsafeSlice bs i_ m_)
                (M.basicUnsafeSlice cs i_ m_)
                (M.basicUnsafeSlice ds i_ m_)
                (M.basicUnsafeSlice es i_ m_)
                (M.basicUnsafeSlice fs i_ m_)
                (M.basicUnsafeSlice gs i_ m_)
                (M.basicUnsafeSlice hs i_ m_)
                (M.basicUnsafeSlice is i_ m_)
  {-# INLINE basicOverlaps  #-}
  basicOverlaps (MV_9 n_1 as1
                          bs1
                          cs1
                          ds1
                          es1
                          fs1
                          gs1
                          hs1
                          is1) (MV_9 n_2 as2 bs2 cs2 ds2 es2 fs2 gs2 hs2 is2)
      = M.basicOverlaps as1 as2
        || M.basicOverlaps bs1 bs2
        || M.basicOverlaps cs1 cs2
        || M.basicOverlaps ds1 ds2
        || M.basicOverlaps es1 es2
        || M.basicOverlaps fs1 fs2
        || M.basicOverlaps gs1 gs2
        || M.basicOverlaps hs1 hs2
        || M.basicOverlaps is1 is2
  {-# INLINE basicUnsafeNew  #-}
  basicUnsafeNew n_
      = do
          as <- M.basicUnsafeNew n_
          bs <- M.basicUnsafeNew n_
          cs <- M.basicUnsafeNew n_
          ds <- M.basicUnsafeNew n_
          es <- M.basicUnsafeNew n_
          fs <- M.basicUnsafeNew n_
          gs <- M.basicUnsafeNew n_
          hs <- M.basicUnsafeNew n_
          is <- M.basicUnsafeNew n_
          return $ MV_9 n_ as bs cs ds es fs gs hs is
  {-# INLINE basicUnsafeNewWith  #-}
  basicUnsafeNewWith n_ (a, b, c, d, e, f, g, h, i)
      = do
          as <- M.basicUnsafeNewWith n_ a
          bs <- M.basicUnsafeNewWith n_ b
          cs <- M.basicUnsafeNewWith n_ c
          ds <- M.basicUnsafeNewWith n_ d
          es <- M.basicUnsafeNewWith n_ e
          fs <- M.basicUnsafeNewWith n_ f
          gs <- M.basicUnsafeNewWith n_ g
          hs <- M.basicUnsafeNewWith n_ h
          is <- M.basicUnsafeNewWith n_ i
          return $ MV_9 n_ as bs cs ds es fs gs hs is
  {-# INLINE basicUnsafeRead  #-}
  basicUnsafeRead (MV_9 n_ as bs cs ds es fs gs hs is) i_
      = do
          a <- M.basicUnsafeRead as i_
          b <- M.basicUnsafeRead bs i_
          c <- M.basicUnsafeRead cs i_
          d <- M.basicUnsafeRead ds i_
          e <- M.basicUnsafeRead es i_
          f <- M.basicUnsafeRead fs i_
          g <- M.basicUnsafeRead gs i_
          h <- M.basicUnsafeRead hs i_
          i <- M.basicUnsafeRead is i_
          return (a, b, c, d, e, f, g, h, i)
  {-# INLINE basicUnsafeWrite  #-}
  basicUnsafeWrite (MV_9 n_ as
                            bs
                            cs
                            ds
                            es
                            fs
                            gs
                            hs
                            is) i_ (a, b, c, d, e, f, g, h, i)
      = do
          M.basicUnsafeWrite as i_ a
          M.basicUnsafeWrite bs i_ b
          M.basicUnsafeWrite cs i_ c
          M.basicUnsafeWrite ds i_ d
          M.basicUnsafeWrite es i_ e
          M.basicUnsafeWrite fs i_ f
          M.basicUnsafeWrite gs i_ g
          M.basicUnsafeWrite hs i_ h
          M.basicUnsafeWrite is i_ i
  {-# INLINE basicClear  #-}
  basicClear (MV_9 n_ as bs cs ds es fs gs hs is)
      = do
          M.basicClear as
          M.basicClear bs
          M.basicClear cs
          M.basicClear ds
          M.basicClear es
          M.basicClear fs
          M.basicClear gs
          M.basicClear hs
          M.basicClear is
  {-# INLINE basicSet  #-}
  basicSet (MV_9 n_ as
                    bs
                    cs
                    ds
                    es
                    fs
                    gs
                    hs
                    is) (a, b, c, d, e, f, g, h, i)
      = do
          M.basicSet as a
          M.basicSet bs b
          M.basicSet cs c
          M.basicSet ds d
          M.basicSet es e
          M.basicSet fs f
          M.basicSet gs g
          M.basicSet hs h
          M.basicSet is i
  {-# INLINE basicUnsafeCopy  #-}
  basicUnsafeCopy (MV_9 n_1 as1
                            bs1
                            cs1
                            ds1
                            es1
                            fs1
                            gs1
                            hs1
                            is1) (MV_9 n_2 as2 bs2 cs2 ds2 es2 fs2 gs2 hs2 is2)
      = do
          M.basicUnsafeCopy as1 as2
          M.basicUnsafeCopy bs1 bs2
          M.basicUnsafeCopy cs1 cs2
          M.basicUnsafeCopy ds1 ds2
          M.basicUnsafeCopy es1 es2
          M.basicUnsafeCopy fs1 fs2
          M.basicUnsafeCopy gs1 gs2
          M.basicUnsafeCopy hs1 hs2
          M.basicUnsafeCopy is1 is2
  {-# INLINE basicUnsafeGrow  #-}
  basicUnsafeGrow (MV_9 n_ as bs cs ds es fs gs hs is) m_
      = do
          M.basicUnsafeGrow as m_
          M.basicUnsafeGrow bs m_
          M.basicUnsafeGrow cs m_
          M.basicUnsafeGrow ds m_
          M.basicUnsafeGrow es m_
          M.basicUnsafeGrow fs m_
          M.basicUnsafeGrow gs m_
          M.basicUnsafeGrow hs m_
          M.basicUnsafeGrow is m_
          return $ MV_9 (m_+n_) as bs cs ds es fs gs hs is
instance (Unbox a,
          Unbox b,
          Unbox c,
          Unbox d,
          Unbox e,
          Unbox f,
          Unbox g,
          Unbox h,
          Unbox i) => G.Vector Vector (a, b, c, d, e, f, g, h, i) where
  {-# INLINE unsafeFreeze  #-}
  unsafeFreeze (MV_9 n_ as bs cs ds es fs gs hs is)
      = do
          as' <- G.unsafeFreeze as
          bs' <- G.unsafeFreeze bs
          cs' <- G.unsafeFreeze cs
          ds' <- G.unsafeFreeze ds
          es' <- G.unsafeFreeze es
          fs' <- G.unsafeFreeze fs
          gs' <- G.unsafeFreeze gs
          hs' <- G.unsafeFreeze hs
          is' <- G.unsafeFreeze is
          return $ V_9 n_ as' bs' cs' ds' es' fs' gs' hs' is'
  {-# INLINE basicLength  #-}
  basicLength (V_9 n_ as bs cs ds es fs gs hs is) = n_
  {-# INLINE basicUnsafeSlice  #-}
  basicUnsafeSlice (V_9 n_ as bs cs ds es fs gs hs is) i_ m_
      = V_9 m_ (G.basicUnsafeSlice as i_ m_)
               (G.basicUnsafeSlice bs i_ m_)
               (G.basicUnsafeSlice cs i_ m_)
               (G.basicUnsafeSlice ds i_ m_)
               (G.basicUnsafeSlice es i_ m_)
               (G.basicUnsafeSlice fs i_ m_)
               (G.basicUnsafeSlice gs i_ m_)
               (G.basicUnsafeSlice hs i_ m_)
               (G.basicUnsafeSlice is i_ m_)
  {-# INLINE basicUnsafeIndexM  #-}
  basicUnsafeIndexM (V_9 n_ as bs cs ds es fs gs hs is) i_
      = do
          a <- G.basicUnsafeIndexM as i_
          b <- G.basicUnsafeIndexM bs i_
          c <- G.basicUnsafeIndexM cs i_
          d <- G.basicUnsafeIndexM ds i_
          e <- G.basicUnsafeIndexM es i_
          f <- G.basicUnsafeIndexM fs i_
          g <- G.basicUnsafeIndexM gs i_
          h <- G.basicUnsafeIndexM hs i_
          i <- G.basicUnsafeIndexM is i_
          return (a, b, c, d, e, f, g, h, i)
#endif
#ifdef DEFINE_MUTABLE
zip9 :: (Unbox a,
         Unbox b,
         Unbox c,
         Unbox d,
         Unbox e,
         Unbox f,
         Unbox g,
         Unbox h,
         Unbox i) => MVector s a ->
                     MVector s b ->
                     MVector s c ->
                     MVector s d ->
                     MVector s e ->
                     MVector s f ->
                     MVector s g ->
                     MVector s h ->
                     MVector s i -> MVector s (a, b, c, d, e, f, g, h, i)
{-# INLINE zip9 #-}
zip9 as bs cs ds es fs gs hs is = MV_9 len (unsafeSlice as 0 len)
                                           (unsafeSlice bs 0 len)
                                           (unsafeSlice cs 0 len)
                                           (unsafeSlice ds 0 len)
                                           (unsafeSlice es 0 len)
                                           (unsafeSlice fs 0 len)
                                           (unsafeSlice gs 0 len)
                                           (unsafeSlice hs 0 len)
                                           (unsafeSlice is 0 len)
  where
    len = length as `min`
          length bs `min`
          length cs `min`
          length ds `min`
          length es `min`
          length fs `min`
          length gs `min`
          length hs `min`
          length is
unzip9 :: (Unbox a,
           Unbox b,
           Unbox c,
           Unbox d,
           Unbox e,
           Unbox f,
           Unbox g,
           Unbox h,
           Unbox i) => MVector s (a, b, c, d, e, f, g, h, i) -> (MVector s a,
                                                                 MVector s b,
                                                                 MVector s c,
                                                                 MVector s d,
                                                                 MVector s e,
                                                                 MVector s f,
                                                                 MVector s g,
                                                                 MVector s h,
                                                                 MVector s i)
{-# INLINE unzip9 #-}
unzip9 (MV_9 n_ as bs cs ds es fs gs hs is) = (as,
                                               bs,
                                               cs,
                                               ds,
                                               es,
                                               fs,
                                               gs,
                                               hs,
                                               is)
#endif
#ifdef DEFINE_IMMUTABLE
zip9 :: (Unbox a,
         Unbox b,
         Unbox c,
         Unbox d,
         Unbox e,
         Unbox f,
         Unbox g,
         Unbox h,
         Unbox i) => Vector a ->
                     Vector b ->
                     Vector c ->
                     Vector d ->
                     Vector e ->
                     Vector f ->
                     Vector g ->
                     Vector h ->
                     Vector i -> Vector (a, b, c, d, e, f, g, h, i)
{-# INLINE zip9 #-}
zip9 as bs cs ds es fs gs hs is = V_9 len (unsafeSlice as 0 len)
                                          (unsafeSlice bs 0 len)
                                          (unsafeSlice cs 0 len)
                                          (unsafeSlice ds 0 len)
                                          (unsafeSlice es 0 len)
                                          (unsafeSlice fs 0 len)
                                          (unsafeSlice gs 0 len)
                                          (unsafeSlice hs 0 len)
                                          (unsafeSlice is 0 len)
  where
    len = length as `min`
          length bs `min`
          length cs `min`
          length ds `min`
          length es `min`
          length fs `min`
          length gs `min`
          length hs `min`
          length is
unzip9 :: (Unbox a,
           Unbox b,
           Unbox c,
           Unbox d,
           Unbox e,
           Unbox f,
           Unbox g,
           Unbox h,
           Unbox i) => Vector (a, b, c, d, e, f, g, h, i) -> (Vector a,
                                                              Vector b,
                                                              Vector c,
                                                              Vector d,
                                                              Vector e,
                                                              Vector f,
                                                              Vector g,
                                                              Vector h,
                                                              Vector i)
{-# INLINE unzip9 #-}
unzip9 (V_9 n_ as bs cs ds es fs gs hs is) = (as,
                                              bs,
                                              cs,
                                              ds,
                                              es,
                                              fs,
                                              gs,
                                              hs,
                                              is)
#endif
#ifdef DEFINE_INSTANCES
data instance MVector s (a, b, c, d, e, f, g, h, i, j)
    = MV_10 {-# UNPACK #-} !Int (MVector s a)
                                (MVector s b)
                                (MVector s c)
                                (MVector s d)
                                (MVector s e)
                                (MVector s f)
                                (MVector s g)
                                (MVector s h)
                                (MVector s i)
                                (MVector s j)
data instance Vector (a, b, c, d, e, f, g, h, i, j)
    = V_10 {-# UNPACK #-} !Int (Vector a)
                               (Vector b)
                               (Vector c)
                               (Vector d)
                               (Vector e)
                               (Vector f)
                               (Vector g)
                               (Vector h)
                               (Vector i)
                               (Vector j)
instance (Unbox a,
          Unbox b,
          Unbox c,
          Unbox d,
          Unbox e,
          Unbox f,
          Unbox g,
          Unbox h,
          Unbox i,
          Unbox j) => Unbox (a, b, c, d, e, f, g, h, i, j)
instance (Unbox a,
          Unbox b,
          Unbox c,
          Unbox d,
          Unbox e,
          Unbox f,
          Unbox g,
          Unbox h,
          Unbox i,
          Unbox j) => M.MVector MVector (a, b, c, d, e, f, g, h, i, j) where
  {-# INLINE basicLength  #-}
  basicLength (MV_10 n_ as bs cs ds es fs gs hs is js) = n_
  {-# INLINE basicUnsafeSlice  #-}
  basicUnsafeSlice (MV_10 n_ as bs cs ds es fs gs hs is js) i_ m_
      = MV_10 m_ (M.basicUnsafeSlice as i_ m_)
                 (M.basicUnsafeSlice bs i_ m_)
                 (M.basicUnsafeSlice cs i_ m_)
                 (M.basicUnsafeSlice ds i_ m_)
                 (M.basicUnsafeSlice es i_ m_)
                 (M.basicUnsafeSlice fs i_ m_)
                 (M.basicUnsafeSlice gs i_ m_)
                 (M.basicUnsafeSlice hs i_ m_)
                 (M.basicUnsafeSlice is i_ m_)
                 (M.basicUnsafeSlice js i_ m_)
  {-# INLINE basicOverlaps  #-}
  basicOverlaps (MV_10 n_1 as1
                           bs1
                           cs1
                           ds1
                           es1
                           fs1
                           gs1
                           hs1
                           is1
                           js1) (MV_10 n_2 as2 bs2 cs2 ds2 es2 fs2 gs2 hs2 is2 js2)
      = M.basicOverlaps as1 as2
        || M.basicOverlaps bs1 bs2
        || M.basicOverlaps cs1 cs2
        || M.basicOverlaps ds1 ds2
        || M.basicOverlaps es1 es2
        || M.basicOverlaps fs1 fs2
        || M.basicOverlaps gs1 gs2
        || M.basicOverlaps hs1 hs2
        || M.basicOverlaps is1 is2
        || M.basicOverlaps js1 js2
  {-# INLINE basicUnsafeNew  #-}
  basicUnsafeNew n_
      = do
          as <- M.basicUnsafeNew n_
          bs <- M.basicUnsafeNew n_
          cs <- M.basicUnsafeNew n_
          ds <- M.basicUnsafeNew n_
          es <- M.basicUnsafeNew n_
          fs <- M.basicUnsafeNew n_
          gs <- M.basicUnsafeNew n_
          hs <- M.basicUnsafeNew n_
          is <- M.basicUnsafeNew n_
          js <- M.basicUnsafeNew n_
          return $ MV_10 n_ as bs cs ds es fs gs hs is js
  {-# INLINE basicUnsafeNewWith  #-}
  basicUnsafeNewWith n_ (a, b, c, d, e, f, g, h, i, j)
      = do
          as <- M.basicUnsafeNewWith n_ a
          bs <- M.basicUnsafeNewWith n_ b
          cs <- M.basicUnsafeNewWith n_ c
          ds <- M.basicUnsafeNewWith n_ d
          es <- M.basicUnsafeNewWith n_ e
          fs <- M.basicUnsafeNewWith n_ f
          gs <- M.basicUnsafeNewWith n_ g
          hs <- M.basicUnsafeNewWith n_ h
          is <- M.basicUnsafeNewWith n_ i
          js <- M.basicUnsafeNewWith n_ j
          return $ MV_10 n_ as bs cs ds es fs gs hs is js
  {-# INLINE basicUnsafeRead  #-}
  basicUnsafeRead (MV_10 n_ as bs cs ds es fs gs hs is js) i_
      = do
          a <- M.basicUnsafeRead as i_
          b <- M.basicUnsafeRead bs i_
          c <- M.basicUnsafeRead cs i_
          d <- M.basicUnsafeRead ds i_
          e <- M.basicUnsafeRead es i_
          f <- M.basicUnsafeRead fs i_
          g <- M.basicUnsafeRead gs i_
          h <- M.basicUnsafeRead hs i_
          i <- M.basicUnsafeRead is i_
          j <- M.basicUnsafeRead js i_
          return (a, b, c, d, e, f, g, h, i, j)
  {-# INLINE basicUnsafeWrite  #-}
  basicUnsafeWrite (MV_10 n_ as
                             bs
                             cs
                             ds
                             es
                             fs
                             gs
                             hs
                             is
                             js) i_ (a, b, c, d, e, f, g, h, i, j)
      = do
          M.basicUnsafeWrite as i_ a
          M.basicUnsafeWrite bs i_ b
          M.basicUnsafeWrite cs i_ c
          M.basicUnsafeWrite ds i_ d
          M.basicUnsafeWrite es i_ e
          M.basicUnsafeWrite fs i_ f
          M.basicUnsafeWrite gs i_ g
          M.basicUnsafeWrite hs i_ h
          M.basicUnsafeWrite is i_ i
          M.basicUnsafeWrite js i_ j
  {-# INLINE basicClear  #-}
  basicClear (MV_10 n_ as bs cs ds es fs gs hs is js)
      = do
          M.basicClear as
          M.basicClear bs
          M.basicClear cs
          M.basicClear ds
          M.basicClear es
          M.basicClear fs
          M.basicClear gs
          M.basicClear hs
          M.basicClear is
          M.basicClear js
  {-# INLINE basicSet  #-}
  basicSet (MV_10 n_ as
                     bs
                     cs
                     ds
                     es
                     fs
                     gs
                     hs
                     is
                     js) (a, b, c, d, e, f, g, h, i, j)
      = do
          M.basicSet as a
          M.basicSet bs b
          M.basicSet cs c
          M.basicSet ds d
          M.basicSet es e
          M.basicSet fs f
          M.basicSet gs g
          M.basicSet hs h
          M.basicSet is i
          M.basicSet js j
  {-# INLINE basicUnsafeCopy  #-}
  basicUnsafeCopy (MV_10 n_1 as1
                             bs1
                             cs1
                             ds1
                             es1
                             fs1
                             gs1
                             hs1
                             is1
                             js1) (MV_10 n_2 as2 bs2 cs2 ds2 es2 fs2 gs2 hs2 is2 js2)
      = do
          M.basicUnsafeCopy as1 as2
          M.basicUnsafeCopy bs1 bs2
          M.basicUnsafeCopy cs1 cs2
          M.basicUnsafeCopy ds1 ds2
          M.basicUnsafeCopy es1 es2
          M.basicUnsafeCopy fs1 fs2
          M.basicUnsafeCopy gs1 gs2
          M.basicUnsafeCopy hs1 hs2
          M.basicUnsafeCopy is1 is2
          M.basicUnsafeCopy js1 js2
  {-# INLINE basicUnsafeGrow  #-}
  basicUnsafeGrow (MV_10 n_ as bs cs ds es fs gs hs is js) m_
      = do
          M.basicUnsafeGrow as m_
          M.basicUnsafeGrow bs m_
          M.basicUnsafeGrow cs m_
          M.basicUnsafeGrow ds m_
          M.basicUnsafeGrow es m_
          M.basicUnsafeGrow fs m_
          M.basicUnsafeGrow gs m_
          M.basicUnsafeGrow hs m_
          M.basicUnsafeGrow is m_
          M.basicUnsafeGrow js m_
          return $ MV_10 (m_+n_) as bs cs ds es fs gs hs is js
instance (Unbox a,
          Unbox b,
          Unbox c,
          Unbox d,
          Unbox e,
          Unbox f,
          Unbox g,
          Unbox h,
          Unbox i,
          Unbox j) => G.Vector Vector (a, b, c, d, e, f, g, h, i, j) where
  {-# INLINE unsafeFreeze  #-}
  unsafeFreeze (MV_10 n_ as bs cs ds es fs gs hs is js)
      = do
          as' <- G.unsafeFreeze as
          bs' <- G.unsafeFreeze bs
          cs' <- G.unsafeFreeze cs
          ds' <- G.unsafeFreeze ds
          es' <- G.unsafeFreeze es
          fs' <- G.unsafeFreeze fs
          gs' <- G.unsafeFreeze gs
          hs' <- G.unsafeFreeze hs
          is' <- G.unsafeFreeze is
          js' <- G.unsafeFreeze js
          return $ V_10 n_ as' bs' cs' ds' es' fs' gs' hs' is' js'
  {-# INLINE basicLength  #-}
  basicLength (V_10 n_ as bs cs ds es fs gs hs is js) = n_
  {-# INLINE basicUnsafeSlice  #-}
  basicUnsafeSlice (V_10 n_ as bs cs ds es fs gs hs is js) i_ m_
      = V_10 m_ (G.basicUnsafeSlice as i_ m_)
                (G.basicUnsafeSlice bs i_ m_)
                (G.basicUnsafeSlice cs i_ m_)
                (G.basicUnsafeSlice ds i_ m_)
                (G.basicUnsafeSlice es i_ m_)
                (G.basicUnsafeSlice fs i_ m_)
                (G.basicUnsafeSlice gs i_ m_)
                (G.basicUnsafeSlice hs i_ m_)
                (G.basicUnsafeSlice is i_ m_)
                (G.basicUnsafeSlice js i_ m_)
  {-# INLINE basicUnsafeIndexM  #-}
  basicUnsafeIndexM (V_10 n_ as bs cs ds es fs gs hs is js) i_
      = do
          a <- G.basicUnsafeIndexM as i_
          b <- G.basicUnsafeIndexM bs i_
          c <- G.basicUnsafeIndexM cs i_
          d <- G.basicUnsafeIndexM ds i_
          e <- G.basicUnsafeIndexM es i_
          f <- G.basicUnsafeIndexM fs i_
          g <- G.basicUnsafeIndexM gs i_
          h <- G.basicUnsafeIndexM hs i_
          i <- G.basicUnsafeIndexM is i_
          j <- G.basicUnsafeIndexM js i_
          return (a, b, c, d, e, f, g, h, i, j)
#endif
#ifdef DEFINE_MUTABLE
zip10 :: (Unbox a,
          Unbox b,
          Unbox c,
          Unbox d,
          Unbox e,
          Unbox f,
          Unbox g,
          Unbox h,
          Unbox i,
          Unbox j) => MVector s a ->
                      MVector s b ->
                      MVector s c ->
                      MVector s d ->
                      MVector s e ->
                      MVector s f ->
                      MVector s g ->
                      MVector s h ->
                      MVector s i ->
                      MVector s j -> MVector s (a, b, c, d, e, f, g, h, i, j)
{-# INLINE zip10 #-}
zip10 as
      bs
      cs
      ds
      es
      fs
      gs
      hs
      is
      js = MV_10 len (unsafeSlice as 0 len)
                     (unsafeSlice bs 0 len)
                     (unsafeSlice cs 0 len)
                     (unsafeSlice ds 0 len)
                     (unsafeSlice es 0 len)
                     (unsafeSlice fs 0 len)
                     (unsafeSlice gs 0 len)
                     (unsafeSlice hs 0 len)
                     (unsafeSlice is 0 len)
                     (unsafeSlice js 0 len)
  where
    len = length as `min`
          length bs `min`
          length cs `min`
          length ds `min`
          length es `min`
          length fs `min`
          length gs `min`
          length hs `min`
          length is `min`
          length js
unzip10 :: (Unbox a,
            Unbox b,
            Unbox c,
            Unbox d,
            Unbox e,
            Unbox f,
            Unbox g,
            Unbox h,
            Unbox i,
            Unbox j) => MVector s (a, b, c, d, e, f, g, h, i, j) -> (MVector s a,
                                                                     MVector s b,
                                                                     MVector s c,
                                                                     MVector s d,
                                                                     MVector s e,
                                                                     MVector s f,
                                                                     MVector s g,
                                                                     MVector s h,
                                                                     MVector s i,
                                                                     MVector s j)
{-# INLINE unzip10 #-}
unzip10 (MV_10 n_ as bs cs ds es fs gs hs is js) = (as,
                                                    bs,
                                                    cs,
                                                    ds,
                                                    es,
                                                    fs,
                                                    gs,
                                                    hs,
                                                    is,
                                                    js)
#endif
#ifdef DEFINE_IMMUTABLE
zip10 :: (Unbox a,
          Unbox b,
          Unbox c,
          Unbox d,
          Unbox e,
          Unbox f,
          Unbox g,
          Unbox h,
          Unbox i,
          Unbox j) => Vector a ->
                      Vector b ->
                      Vector c ->
                      Vector d ->
                      Vector e ->
                      Vector f ->
                      Vector g ->
                      Vector h ->
                      Vector i ->
                      Vector j -> Vector (a, b, c, d, e, f, g, h, i, j)
{-# INLINE zip10 #-}
zip10 as
      bs
      cs
      ds
      es
      fs
      gs
      hs
      is
      js = V_10 len (unsafeSlice as 0 len)
                    (unsafeSlice bs 0 len)
                    (unsafeSlice cs 0 len)
                    (unsafeSlice ds 0 len)
                    (unsafeSlice es 0 len)
                    (unsafeSlice fs 0 len)
                    (unsafeSlice gs 0 len)
                    (unsafeSlice hs 0 len)
                    (unsafeSlice is 0 len)
                    (unsafeSlice js 0 len)
  where
    len = length as `min`
          length bs `min`
          length cs `min`
          length ds `min`
          length es `min`
          length fs `min`
          length gs `min`
          length hs `min`
          length is `min`
          length js
unzip10 :: (Unbox a,
            Unbox b,
            Unbox c,
            Unbox d,
            Unbox e,
            Unbox f,
            Unbox g,
            Unbox h,
            Unbox i,
            Unbox j) => Vector (a, b, c, d, e, f, g, h, i, j) -> (Vector a,
                                                                  Vector b,
                                                                  Vector c,
                                                                  Vector d,
                                                                  Vector e,
                                                                  Vector f,
                                                                  Vector g,
                                                                  Vector h,
                                                                  Vector i,
                                                                  Vector j)
{-# INLINE unzip10 #-}
unzip10 (V_10 n_ as bs cs ds es fs gs hs is js) = (as,
                                                   bs,
                                                   cs,
                                                   ds,
                                                   es,
                                                   fs,
                                                   gs,
                                                   hs,
                                                   is,
                                                   js)
#endif
#ifdef DEFINE_INSTANCES
data instance MVector s (a, b, c, d, e, f, g, h, i, j, k)
    = MV_11 {-# UNPACK #-} !Int (MVector s a)
                                (MVector s b)
                                (MVector s c)
                                (MVector s d)
                                (MVector s e)
                                (MVector s f)
                                (MVector s g)
                                (MVector s h)
                                (MVector s i)
                                (MVector s j)
                                (MVector s k)
data instance Vector (a, b, c, d, e, f, g, h, i, j, k)
    = V_11 {-# UNPACK #-} !Int (Vector a)
                               (Vector b)
                               (Vector c)
                               (Vector d)
                               (Vector e)
                               (Vector f)
                               (Vector g)
                               (Vector h)
                               (Vector i)
                               (Vector j)
                               (Vector k)
instance (Unbox a,
          Unbox b,
          Unbox c,
          Unbox d,
          Unbox e,
          Unbox f,
          Unbox g,
          Unbox h,
          Unbox i,
          Unbox j,
          Unbox k) => Unbox (a, b, c, d, e, f, g, h, i, j, k)
instance (Unbox a,
          Unbox b,
          Unbox c,
          Unbox d,
          Unbox e,
          Unbox f,
          Unbox g,
          Unbox h,
          Unbox i,
          Unbox j,
          Unbox k) => M.MVector MVector (a, b, c, d, e, f, g, h, i, j, k) where
  {-# INLINE basicLength  #-}
  basicLength (MV_11 n_ as bs cs ds es fs gs hs is js ks) = n_
  {-# INLINE basicUnsafeSlice  #-}
  basicUnsafeSlice (MV_11 n_ as bs cs ds es fs gs hs is js ks) i_ m_
      = MV_11 m_ (M.basicUnsafeSlice as i_ m_)
                 (M.basicUnsafeSlice bs i_ m_)
                 (M.basicUnsafeSlice cs i_ m_)
                 (M.basicUnsafeSlice ds i_ m_)
                 (M.basicUnsafeSlice es i_ m_)
                 (M.basicUnsafeSlice fs i_ m_)
                 (M.basicUnsafeSlice gs i_ m_)
                 (M.basicUnsafeSlice hs i_ m_)
                 (M.basicUnsafeSlice is i_ m_)
                 (M.basicUnsafeSlice js i_ m_)
                 (M.basicUnsafeSlice ks i_ m_)
  {-# INLINE basicOverlaps  #-}
  basicOverlaps (MV_11 n_1 as1
                           bs1
                           cs1
                           ds1
                           es1
                           fs1
                           gs1
                           hs1
                           is1
                           js1
                           ks1) (MV_11 n_2 as2 bs2 cs2 ds2 es2 fs2 gs2 hs2 is2 js2 ks2)
      = M.basicOverlaps as1 as2
        || M.basicOverlaps bs1 bs2
        || M.basicOverlaps cs1 cs2
        || M.basicOverlaps ds1 ds2
        || M.basicOverlaps es1 es2
        || M.basicOverlaps fs1 fs2
        || M.basicOverlaps gs1 gs2
        || M.basicOverlaps hs1 hs2
        || M.basicOverlaps is1 is2
        || M.basicOverlaps js1 js2
        || M.basicOverlaps ks1 ks2
  {-# INLINE basicUnsafeNew  #-}
  basicUnsafeNew n_
      = do
          as <- M.basicUnsafeNew n_
          bs <- M.basicUnsafeNew n_
          cs <- M.basicUnsafeNew n_
          ds <- M.basicUnsafeNew n_
          es <- M.basicUnsafeNew n_
          fs <- M.basicUnsafeNew n_
          gs <- M.basicUnsafeNew n_
          hs <- M.basicUnsafeNew n_
          is <- M.basicUnsafeNew n_
          js <- M.basicUnsafeNew n_
          ks <- M.basicUnsafeNew n_
          return $ MV_11 n_ as bs cs ds es fs gs hs is js ks
  {-# INLINE basicUnsafeNewWith  #-}
  basicUnsafeNewWith n_ (a, b, c, d, e, f, g, h, i, j, k)
      = do
          as <- M.basicUnsafeNewWith n_ a
          bs <- M.basicUnsafeNewWith n_ b
          cs <- M.basicUnsafeNewWith n_ c
          ds <- M.basicUnsafeNewWith n_ d
          es <- M.basicUnsafeNewWith n_ e
          fs <- M.basicUnsafeNewWith n_ f
          gs <- M.basicUnsafeNewWith n_ g
          hs <- M.basicUnsafeNewWith n_ h
          is <- M.basicUnsafeNewWith n_ i
          js <- M.basicUnsafeNewWith n_ j
          ks <- M.basicUnsafeNewWith n_ k
          return $ MV_11 n_ as bs cs ds es fs gs hs is js ks
  {-# INLINE basicUnsafeRead  #-}
  basicUnsafeRead (MV_11 n_ as bs cs ds es fs gs hs is js ks) i_
      = do
          a <- M.basicUnsafeRead as i_
          b <- M.basicUnsafeRead bs i_
          c <- M.basicUnsafeRead cs i_
          d <- M.basicUnsafeRead ds i_
          e <- M.basicUnsafeRead es i_
          f <- M.basicUnsafeRead fs i_
          g <- M.basicUnsafeRead gs i_
          h <- M.basicUnsafeRead hs i_
          i <- M.basicUnsafeRead is i_
          j <- M.basicUnsafeRead js i_
          k <- M.basicUnsafeRead ks i_
          return (a, b, c, d, e, f, g, h, i, j, k)
  {-# INLINE basicUnsafeWrite  #-}
  basicUnsafeWrite (MV_11 n_ as
                             bs
                             cs
                             ds
                             es
                             fs
                             gs
                             hs
                             is
                             js
                             ks) i_ (a, b, c, d, e, f, g, h, i, j, k)
      = do
          M.basicUnsafeWrite as i_ a
          M.basicUnsafeWrite bs i_ b
          M.basicUnsafeWrite cs i_ c
          M.basicUnsafeWrite ds i_ d
          M.basicUnsafeWrite es i_ e
          M.basicUnsafeWrite fs i_ f
          M.basicUnsafeWrite gs i_ g
          M.basicUnsafeWrite hs i_ h
          M.basicUnsafeWrite is i_ i
          M.basicUnsafeWrite js i_ j
          M.basicUnsafeWrite ks i_ k
  {-# INLINE basicClear  #-}
  basicClear (MV_11 n_ as bs cs ds es fs gs hs is js ks)
      = do
          M.basicClear as
          M.basicClear bs
          M.basicClear cs
          M.basicClear ds
          M.basicClear es
          M.basicClear fs
          M.basicClear gs
          M.basicClear hs
          M.basicClear is
          M.basicClear js
          M.basicClear ks
  {-# INLINE basicSet  #-}
  basicSet (MV_11 n_ as
                     bs
                     cs
                     ds
                     es
                     fs
                     gs
                     hs
                     is
                     js
                     ks) (a, b, c, d, e, f, g, h, i, j, k)
      = do
          M.basicSet as a
          M.basicSet bs b
          M.basicSet cs c
          M.basicSet ds d
          M.basicSet es e
          M.basicSet fs f
          M.basicSet gs g
          M.basicSet hs h
          M.basicSet is i
          M.basicSet js j
          M.basicSet ks k
  {-# INLINE basicUnsafeCopy  #-}
  basicUnsafeCopy (MV_11 n_1 as1
                             bs1
                             cs1
                             ds1
                             es1
                             fs1
                             gs1
                             hs1
                             is1
                             js1
                             ks1) (MV_11 n_2 as2 bs2 cs2 ds2 es2 fs2 gs2 hs2 is2 js2 ks2)
      = do
          M.basicUnsafeCopy as1 as2
          M.basicUnsafeCopy bs1 bs2
          M.basicUnsafeCopy cs1 cs2
          M.basicUnsafeCopy ds1 ds2
          M.basicUnsafeCopy es1 es2
          M.basicUnsafeCopy fs1 fs2
          M.basicUnsafeCopy gs1 gs2
          M.basicUnsafeCopy hs1 hs2
          M.basicUnsafeCopy is1 is2
          M.basicUnsafeCopy js1 js2
          M.basicUnsafeCopy ks1 ks2
  {-# INLINE basicUnsafeGrow  #-}
  basicUnsafeGrow (MV_11 n_ as bs cs ds es fs gs hs is js ks) m_
      = do
          M.basicUnsafeGrow as m_
          M.basicUnsafeGrow bs m_
          M.basicUnsafeGrow cs m_
          M.basicUnsafeGrow ds m_
          M.basicUnsafeGrow es m_
          M.basicUnsafeGrow fs m_
          M.basicUnsafeGrow gs m_
          M.basicUnsafeGrow hs m_
          M.basicUnsafeGrow is m_
          M.basicUnsafeGrow js m_
          M.basicUnsafeGrow ks m_
          return $ MV_11 (m_+n_) as bs cs ds es fs gs hs is js ks
instance (Unbox a,
          Unbox b,
          Unbox c,
          Unbox d,
          Unbox e,
          Unbox f,
          Unbox g,
          Unbox h,
          Unbox i,
          Unbox j,
          Unbox k) => G.Vector Vector (a, b, c, d, e, f, g, h, i, j, k) where
  {-# INLINE unsafeFreeze  #-}
  unsafeFreeze (MV_11 n_ as bs cs ds es fs gs hs is js ks)
      = do
          as' <- G.unsafeFreeze as
          bs' <- G.unsafeFreeze bs
          cs' <- G.unsafeFreeze cs
          ds' <- G.unsafeFreeze ds
          es' <- G.unsafeFreeze es
          fs' <- G.unsafeFreeze fs
          gs' <- G.unsafeFreeze gs
          hs' <- G.unsafeFreeze hs
          is' <- G.unsafeFreeze is
          js' <- G.unsafeFreeze js
          ks' <- G.unsafeFreeze ks
          return $ V_11 n_ as' bs' cs' ds' es' fs' gs' hs' is' js' ks'
  {-# INLINE basicLength  #-}
  basicLength (V_11 n_ as bs cs ds es fs gs hs is js ks) = n_
  {-# INLINE basicUnsafeSlice  #-}
  basicUnsafeSlice (V_11 n_ as bs cs ds es fs gs hs is js ks) i_ m_
      = V_11 m_ (G.basicUnsafeSlice as i_ m_)
                (G.basicUnsafeSlice bs i_ m_)
                (G.basicUnsafeSlice cs i_ m_)
                (G.basicUnsafeSlice ds i_ m_)
                (G.basicUnsafeSlice es i_ m_)
                (G.basicUnsafeSlice fs i_ m_)
                (G.basicUnsafeSlice gs i_ m_)
                (G.basicUnsafeSlice hs i_ m_)
                (G.basicUnsafeSlice is i_ m_)
                (G.basicUnsafeSlice js i_ m_)
                (G.basicUnsafeSlice ks i_ m_)
  {-# INLINE basicUnsafeIndexM  #-}
  basicUnsafeIndexM (V_11 n_ as bs cs ds es fs gs hs is js ks) i_
      = do
          a <- G.basicUnsafeIndexM as i_
          b <- G.basicUnsafeIndexM bs i_
          c <- G.basicUnsafeIndexM cs i_
          d <- G.basicUnsafeIndexM ds i_
          e <- G.basicUnsafeIndexM es i_
          f <- G.basicUnsafeIndexM fs i_
          g <- G.basicUnsafeIndexM gs i_
          h <- G.basicUnsafeIndexM hs i_
          i <- G.basicUnsafeIndexM is i_
          j <- G.basicUnsafeIndexM js i_
          k <- G.basicUnsafeIndexM ks i_
          return (a, b, c, d, e, f, g, h, i, j, k)
#endif
#ifdef DEFINE_MUTABLE
zip11 :: (Unbox a,
          Unbox b,
          Unbox c,
          Unbox d,
          Unbox e,
          Unbox f,
          Unbox g,
          Unbox h,
          Unbox i,
          Unbox j,
          Unbox k) => MVector s a ->
                      MVector s b ->
                      MVector s c ->
                      MVector s d ->
                      MVector s e ->
                      MVector s f ->
                      MVector s g ->
                      MVector s h ->
                      MVector s i ->
                      MVector s j ->
                      MVector s k -> MVector s (a, b, c, d, e, f, g, h, i, j, k)
{-# INLINE zip11 #-}
zip11 as
      bs
      cs
      ds
      es
      fs
      gs
      hs
      is
      js
      ks = MV_11 len (unsafeSlice as 0 len)
                     (unsafeSlice bs 0 len)
                     (unsafeSlice cs 0 len)
                     (unsafeSlice ds 0 len)
                     (unsafeSlice es 0 len)
                     (unsafeSlice fs 0 len)
                     (unsafeSlice gs 0 len)
                     (unsafeSlice hs 0 len)
                     (unsafeSlice is 0 len)
                     (unsafeSlice js 0 len)
                     (unsafeSlice ks 0 len)
  where
    len = length as `min`
          length bs `min`
          length cs `min`
          length ds `min`
          length es `min`
          length fs `min`
          length gs `min`
          length hs `min`
          length is `min`
          length js `min`
          length ks
unzip11 :: (Unbox a,
            Unbox b,
            Unbox c,
            Unbox d,
            Unbox e,
            Unbox f,
            Unbox g,
            Unbox h,
            Unbox i,
            Unbox j,
            Unbox k) => MVector s (a, b, c, d, e, f, g, h, i, j, k) -> (MVector s a,
                                                                        MVector s b,
                                                                        MVector s c,
                                                                        MVector s d,
                                                                        MVector s e,
                                                                        MVector s f,
                                                                        MVector s g,
                                                                        MVector s h,
                                                                        MVector s i,
                                                                        MVector s j,
                                                                        MVector s k)
{-# INLINE unzip11 #-}
unzip11 (MV_11 n_ as bs cs ds es fs gs hs is js ks) = (as,
                                                       bs,
                                                       cs,
                                                       ds,
                                                       es,
                                                       fs,
                                                       gs,
                                                       hs,
                                                       is,
                                                       js,
                                                       ks)
#endif
#ifdef DEFINE_IMMUTABLE
zip11 :: (Unbox a,
          Unbox b,
          Unbox c,
          Unbox d,
          Unbox e,
          Unbox f,
          Unbox g,
          Unbox h,
          Unbox i,
          Unbox j,
          Unbox k) => Vector a ->
                      Vector b ->
                      Vector c ->
                      Vector d ->
                      Vector e ->
                      Vector f ->
                      Vector g ->
                      Vector h ->
                      Vector i ->
                      Vector j ->
                      Vector k -> Vector (a, b, c, d, e, f, g, h, i, j, k)
{-# INLINE zip11 #-}
zip11 as
      bs
      cs
      ds
      es
      fs
      gs
      hs
      is
      js
      ks = V_11 len (unsafeSlice as 0 len)
                    (unsafeSlice bs 0 len)
                    (unsafeSlice cs 0 len)
                    (unsafeSlice ds 0 len)
                    (unsafeSlice es 0 len)
                    (unsafeSlice fs 0 len)
                    (unsafeSlice gs 0 len)
                    (unsafeSlice hs 0 len)
                    (unsafeSlice is 0 len)
                    (unsafeSlice js 0 len)
                    (unsafeSlice ks 0 len)
  where
    len = length as `min`
          length bs `min`
          length cs `min`
          length ds `min`
          length es `min`
          length fs `min`
          length gs `min`
          length hs `min`
          length is `min`
          length js `min`
          length ks
unzip11 :: (Unbox a,
            Unbox b,
            Unbox c,
            Unbox d,
            Unbox e,
            Unbox f,
            Unbox g,
            Unbox h,
            Unbox i,
            Unbox j,
            Unbox k) => Vector (a, b, c, d, e, f, g, h, i, j, k) -> (Vector a,
                                                                     Vector b,
                                                                     Vector c,
                                                                     Vector d,
                                                                     Vector e,
                                                                     Vector f,
                                                                     Vector g,
                                                                     Vector h,
                                                                     Vector i,
                                                                     Vector j,
                                                                     Vector k)
{-# INLINE unzip11 #-}
unzip11 (V_11 n_ as bs cs ds es fs gs hs is js ks) = (as,
                                                      bs,
                                                      cs,
                                                      ds,
                                                      es,
                                                      fs,
                                                      gs,
                                                      hs,
                                                      is,
                                                      js,
                                                      ks)
#endif
#ifdef DEFINE_INSTANCES
data instance MVector s (a, b, c, d, e, f, g, h, i, j, k, l)
    = MV_12 {-# UNPACK #-} !Int (MVector s a)
                                (MVector s b)
                                (MVector s c)
                                (MVector s d)
                                (MVector s e)
                                (MVector s f)
                                (MVector s g)
                                (MVector s h)
                                (MVector s i)
                                (MVector s j)
                                (MVector s k)
                                (MVector s l)
data instance Vector (a, b, c, d, e, f, g, h, i, j, k, l)
    = V_12 {-# UNPACK #-} !Int (Vector a)
                               (Vector b)
                               (Vector c)
                               (Vector d)
                               (Vector e)
                               (Vector f)
                               (Vector g)
                               (Vector h)
                               (Vector i)
                               (Vector j)
                               (Vector k)
                               (Vector l)
instance (Unbox a,
          Unbox b,
          Unbox c,
          Unbox d,
          Unbox e,
          Unbox f,
          Unbox g,
          Unbox h,
          Unbox i,
          Unbox j,
          Unbox k,
          Unbox l) => Unbox (a, b, c, d, e, f, g, h, i, j, k, l)
instance (Unbox a,
          Unbox b,
          Unbox c,
          Unbox d,
          Unbox e,
          Unbox f,
          Unbox g,
          Unbox h,
          Unbox i,
          Unbox j,
          Unbox k,
          Unbox l) => M.MVector MVector (a, b, c, d, e, f, g, h, i, j, k, l) where
  {-# INLINE basicLength  #-}
  basicLength (MV_12 n_ as bs cs ds es fs gs hs is js ks ls) = n_
  {-# INLINE basicUnsafeSlice  #-}
  basicUnsafeSlice (MV_12 n_ as
                             bs
                             cs
                             ds
                             es
                             fs
                             gs
                             hs
                             is
                             js
                             ks
                             ls) i_ m_
      = MV_12 m_ (M.basicUnsafeSlice as i_ m_)
                 (M.basicUnsafeSlice bs i_ m_)
                 (M.basicUnsafeSlice cs i_ m_)
                 (M.basicUnsafeSlice ds i_ m_)
                 (M.basicUnsafeSlice es i_ m_)
                 (M.basicUnsafeSlice fs i_ m_)
                 (M.basicUnsafeSlice gs i_ m_)
                 (M.basicUnsafeSlice hs i_ m_)
                 (M.basicUnsafeSlice is i_ m_)
                 (M.basicUnsafeSlice js i_ m_)
                 (M.basicUnsafeSlice ks i_ m_)
                 (M.basicUnsafeSlice ls i_ m_)
  {-# INLINE basicOverlaps  #-}
  basicOverlaps (MV_12 n_1 as1
                           bs1
                           cs1
                           ds1
                           es1
                           fs1
                           gs1
                           hs1
                           is1
                           js1
                           ks1
                           ls1) (MV_12 n_2 as2 bs2 cs2 ds2 es2 fs2 gs2 hs2 is2 js2 ks2 ls2)
      = M.basicOverlaps as1 as2
        || M.basicOverlaps bs1 bs2
        || M.basicOverlaps cs1 cs2
        || M.basicOverlaps ds1 ds2
        || M.basicOverlaps es1 es2
        || M.basicOverlaps fs1 fs2
        || M.basicOverlaps gs1 gs2
        || M.basicOverlaps hs1 hs2
        || M.basicOverlaps is1 is2
        || M.basicOverlaps js1 js2
        || M.basicOverlaps ks1 ks2
        || M.basicOverlaps ls1 ls2
  {-# INLINE basicUnsafeNew  #-}
  basicUnsafeNew n_
      = do
          as <- M.basicUnsafeNew n_
          bs <- M.basicUnsafeNew n_
          cs <- M.basicUnsafeNew n_
          ds <- M.basicUnsafeNew n_
          es <- M.basicUnsafeNew n_
          fs <- M.basicUnsafeNew n_
          gs <- M.basicUnsafeNew n_
          hs <- M.basicUnsafeNew n_
          is <- M.basicUnsafeNew n_
          js <- M.basicUnsafeNew n_
          ks <- M.basicUnsafeNew n_
          ls <- M.basicUnsafeNew n_
          return $ MV_12 n_ as bs cs ds es fs gs hs is js ks ls
  {-# INLINE basicUnsafeNewWith  #-}
  basicUnsafeNewWith n_ (a, b, c, d, e, f, g, h, i, j, k, l)
      = do
          as <- M.basicUnsafeNewWith n_ a
          bs <- M.basicUnsafeNewWith n_ b
          cs <- M.basicUnsafeNewWith n_ c
          ds <- M.basicUnsafeNewWith n_ d
          es <- M.basicUnsafeNewWith n_ e
          fs <- M.basicUnsafeNewWith n_ f
          gs <- M.basicUnsafeNewWith n_ g
          hs <- M.basicUnsafeNewWith n_ h
          is <- M.basicUnsafeNewWith n_ i
          js <- M.basicUnsafeNewWith n_ j
          ks <- M.basicUnsafeNewWith n_ k
          ls <- M.basicUnsafeNewWith n_ l
          return $ MV_12 n_ as bs cs ds es fs gs hs is js ks ls
  {-# INLINE basicUnsafeRead  #-}
  basicUnsafeRead (MV_12 n_ as bs cs ds es fs gs hs is js ks ls) i_
      = do
          a <- M.basicUnsafeRead as i_
          b <- M.basicUnsafeRead bs i_
          c <- M.basicUnsafeRead cs i_
          d <- M.basicUnsafeRead ds i_
          e <- M.basicUnsafeRead es i_
          f <- M.basicUnsafeRead fs i_
          g <- M.basicUnsafeRead gs i_
          h <- M.basicUnsafeRead hs i_
          i <- M.basicUnsafeRead is i_
          j <- M.basicUnsafeRead js i_
          k <- M.basicUnsafeRead ks i_
          l <- M.basicUnsafeRead ls i_
          return (a, b, c, d, e, f, g, h, i, j, k, l)
  {-# INLINE basicUnsafeWrite  #-}
  basicUnsafeWrite (MV_12 n_ as
                             bs
                             cs
                             ds
                             es
                             fs
                             gs
                             hs
                             is
                             js
                             ks
                             ls) i_ (a, b, c, d, e, f, g, h, i, j, k, l)
      = do
          M.basicUnsafeWrite as i_ a
          M.basicUnsafeWrite bs i_ b
          M.basicUnsafeWrite cs i_ c
          M.basicUnsafeWrite ds i_ d
          M.basicUnsafeWrite es i_ e
          M.basicUnsafeWrite fs i_ f
          M.basicUnsafeWrite gs i_ g
          M.basicUnsafeWrite hs i_ h
          M.basicUnsafeWrite is i_ i
          M.basicUnsafeWrite js i_ j
          M.basicUnsafeWrite ks i_ k
          M.basicUnsafeWrite ls i_ l
  {-# INLINE basicClear  #-}
  basicClear (MV_12 n_ as bs cs ds es fs gs hs is js ks ls)
      = do
          M.basicClear as
          M.basicClear bs
          M.basicClear cs
          M.basicClear ds
          M.basicClear es
          M.basicClear fs
          M.basicClear gs
          M.basicClear hs
          M.basicClear is
          M.basicClear js
          M.basicClear ks
          M.basicClear ls
  {-# INLINE basicSet  #-}
  basicSet (MV_12 n_ as
                     bs
                     cs
                     ds
                     es
                     fs
                     gs
                     hs
                     is
                     js
                     ks
                     ls) (a, b, c, d, e, f, g, h, i, j, k, l)
      = do
          M.basicSet as a
          M.basicSet bs b
          M.basicSet cs c
          M.basicSet ds d
          M.basicSet es e
          M.basicSet fs f
          M.basicSet gs g
          M.basicSet hs h
          M.basicSet is i
          M.basicSet js j
          M.basicSet ks k
          M.basicSet ls l
  {-# INLINE basicUnsafeCopy  #-}
  basicUnsafeCopy (MV_12 n_1 as1
                             bs1
                             cs1
                             ds1
                             es1
                             fs1
                             gs1
                             hs1
                             is1
                             js1
                             ks1
                             ls1) (MV_12 n_2 as2 bs2 cs2 ds2 es2 fs2 gs2 hs2 is2 js2 ks2 ls2)
      = do
          M.basicUnsafeCopy as1 as2
          M.basicUnsafeCopy bs1 bs2
          M.basicUnsafeCopy cs1 cs2
          M.basicUnsafeCopy ds1 ds2
          M.basicUnsafeCopy es1 es2
          M.basicUnsafeCopy fs1 fs2
          M.basicUnsafeCopy gs1 gs2
          M.basicUnsafeCopy hs1 hs2
          M.basicUnsafeCopy is1 is2
          M.basicUnsafeCopy js1 js2
          M.basicUnsafeCopy ks1 ks2
          M.basicUnsafeCopy ls1 ls2
  {-# INLINE basicUnsafeGrow  #-}
  basicUnsafeGrow (MV_12 n_ as bs cs ds es fs gs hs is js ks ls) m_
      = do
          M.basicUnsafeGrow as m_
          M.basicUnsafeGrow bs m_
          M.basicUnsafeGrow cs m_
          M.basicUnsafeGrow ds m_
          M.basicUnsafeGrow es m_
          M.basicUnsafeGrow fs m_
          M.basicUnsafeGrow gs m_
          M.basicUnsafeGrow hs m_
          M.basicUnsafeGrow is m_
          M.basicUnsafeGrow js m_
          M.basicUnsafeGrow ks m_
          M.basicUnsafeGrow ls m_
          return $ MV_12 (m_+n_) as bs cs ds es fs gs hs is js ks ls
instance (Unbox a,
          Unbox b,
          Unbox c,
          Unbox d,
          Unbox e,
          Unbox f,
          Unbox g,
          Unbox h,
          Unbox i,
          Unbox j,
          Unbox k,
          Unbox l) => G.Vector Vector (a, b, c, d, e, f, g, h, i, j, k, l) where
  {-# INLINE unsafeFreeze  #-}
  unsafeFreeze (MV_12 n_ as bs cs ds es fs gs hs is js ks ls)
      = do
          as' <- G.unsafeFreeze as
          bs' <- G.unsafeFreeze bs
          cs' <- G.unsafeFreeze cs
          ds' <- G.unsafeFreeze ds
          es' <- G.unsafeFreeze es
          fs' <- G.unsafeFreeze fs
          gs' <- G.unsafeFreeze gs
          hs' <- G.unsafeFreeze hs
          is' <- G.unsafeFreeze is
          js' <- G.unsafeFreeze js
          ks' <- G.unsafeFreeze ks
          ls' <- G.unsafeFreeze ls
          return $ V_12 n_ as' bs' cs' ds' es' fs' gs' hs' is' js' ks' ls'
  {-# INLINE basicLength  #-}
  basicLength (V_12 n_ as bs cs ds es fs gs hs is js ks ls) = n_
  {-# INLINE basicUnsafeSlice  #-}
  basicUnsafeSlice (V_12 n_ as
                            bs
                            cs
                            ds
                            es
                            fs
                            gs
                            hs
                            is
                            js
                            ks
                            ls) i_ m_
      = V_12 m_ (G.basicUnsafeSlice as i_ m_)
                (G.basicUnsafeSlice bs i_ m_)
                (G.basicUnsafeSlice cs i_ m_)
                (G.basicUnsafeSlice ds i_ m_)
                (G.basicUnsafeSlice es i_ m_)
                (G.basicUnsafeSlice fs i_ m_)
                (G.basicUnsafeSlice gs i_ m_)
                (G.basicUnsafeSlice hs i_ m_)
                (G.basicUnsafeSlice is i_ m_)
                (G.basicUnsafeSlice js i_ m_)
                (G.basicUnsafeSlice ks i_ m_)
                (G.basicUnsafeSlice ls i_ m_)
  {-# INLINE basicUnsafeIndexM  #-}
  basicUnsafeIndexM (V_12 n_ as bs cs ds es fs gs hs is js ks ls) i_
      = do
          a <- G.basicUnsafeIndexM as i_
          b <- G.basicUnsafeIndexM bs i_
          c <- G.basicUnsafeIndexM cs i_
          d <- G.basicUnsafeIndexM ds i_
          e <- G.basicUnsafeIndexM es i_
          f <- G.basicUnsafeIndexM fs i_
          g <- G.basicUnsafeIndexM gs i_
          h <- G.basicUnsafeIndexM hs i_
          i <- G.basicUnsafeIndexM is i_
          j <- G.basicUnsafeIndexM js i_
          k <- G.basicUnsafeIndexM ks i_
          l <- G.basicUnsafeIndexM ls i_
          return (a, b, c, d, e, f, g, h, i, j, k, l)
#endif
#ifdef DEFINE_MUTABLE
zip12 :: (Unbox a,
          Unbox b,
          Unbox c,
          Unbox d,
          Unbox e,
          Unbox f,
          Unbox g,
          Unbox h,
          Unbox i,
          Unbox j,
          Unbox k,
          Unbox l) => MVector s a ->
                      MVector s b ->
                      MVector s c ->
                      MVector s d ->
                      MVector s e ->
                      MVector s f ->
                      MVector s g ->
                      MVector s h ->
                      MVector s i ->
                      MVector s j ->
                      MVector s k ->
                      MVector s l -> MVector s (a, b, c, d, e, f, g, h, i, j, k, l)
{-# INLINE zip12 #-}
zip12 as
      bs
      cs
      ds
      es
      fs
      gs
      hs
      is
      js
      ks
      ls = MV_12 len (unsafeSlice as 0 len)
                     (unsafeSlice bs 0 len)
                     (unsafeSlice cs 0 len)
                     (unsafeSlice ds 0 len)
                     (unsafeSlice es 0 len)
                     (unsafeSlice fs 0 len)
                     (unsafeSlice gs 0 len)
                     (unsafeSlice hs 0 len)
                     (unsafeSlice is 0 len)
                     (unsafeSlice js 0 len)
                     (unsafeSlice ks 0 len)
                     (unsafeSlice ls 0 len)
  where
    len = length as `min`
          length bs `min`
          length cs `min`
          length ds `min`
          length es `min`
          length fs `min`
          length gs `min`
          length hs `min`
          length is `min`
          length js `min`
          length ks `min`
          length ls
unzip12 :: (Unbox a,
            Unbox b,
            Unbox c,
            Unbox d,
            Unbox e,
            Unbox f,
            Unbox g,
            Unbox h,
            Unbox i,
            Unbox j,
            Unbox k,
            Unbox l) => MVector s (a, b, c, d, e, f, g, h, i, j, k, l) -> (MVector s a,
                                                                           MVector s b,
                                                                           MVector s c,
                                                                           MVector s d,
                                                                           MVector s e,
                                                                           MVector s f,
                                                                           MVector s g,
                                                                           MVector s h,
                                                                           MVector s i,
                                                                           MVector s j,
                                                                           MVector s k,
                                                                           MVector s l)
{-# INLINE unzip12 #-}
unzip12 (MV_12 n_ as bs cs ds es fs gs hs is js ks ls) = (as,
                                                          bs,
                                                          cs,
                                                          ds,
                                                          es,
                                                          fs,
                                                          gs,
                                                          hs,
                                                          is,
                                                          js,
                                                          ks,
                                                          ls)
#endif
#ifdef DEFINE_IMMUTABLE
zip12 :: (Unbox a,
          Unbox b,
          Unbox c,
          Unbox d,
          Unbox e,
          Unbox f,
          Unbox g,
          Unbox h,
          Unbox i,
          Unbox j,
          Unbox k,
          Unbox l) => Vector a ->
                      Vector b ->
                      Vector c ->
                      Vector d ->
                      Vector e ->
                      Vector f ->
                      Vector g ->
                      Vector h ->
                      Vector i ->
                      Vector j ->
                      Vector k ->
                      Vector l -> Vector (a, b, c, d, e, f, g, h, i, j, k, l)
{-# INLINE zip12 #-}
zip12 as
      bs
      cs
      ds
      es
      fs
      gs
      hs
      is
      js
      ks
      ls = V_12 len (unsafeSlice as 0 len)
                    (unsafeSlice bs 0 len)
                    (unsafeSlice cs 0 len)
                    (unsafeSlice ds 0 len)
                    (unsafeSlice es 0 len)
                    (unsafeSlice fs 0 len)
                    (unsafeSlice gs 0 len)
                    (unsafeSlice hs 0 len)
                    (unsafeSlice is 0 len)
                    (unsafeSlice js 0 len)
                    (unsafeSlice ks 0 len)
                    (unsafeSlice ls 0 len)
  where
    len = length as `min`
          length bs `min`
          length cs `min`
          length ds `min`
          length es `min`
          length fs `min`
          length gs `min`
          length hs `min`
          length is `min`
          length js `min`
          length ks `min`
          length ls
unzip12 :: (Unbox a,
            Unbox b,
            Unbox c,
            Unbox d,
            Unbox e,
            Unbox f,
            Unbox g,
            Unbox h,
            Unbox i,
            Unbox j,
            Unbox k,
            Unbox l) => Vector (a, b, c, d, e, f, g, h, i, j, k, l) -> (Vector a,
                                                                        Vector b,
                                                                        Vector c,
                                                                        Vector d,
                                                                        Vector e,
                                                                        Vector f,
                                                                        Vector g,
                                                                        Vector h,
                                                                        Vector i,
                                                                        Vector j,
                                                                        Vector k,
                                                                        Vector l)
{-# INLINE unzip12 #-}
unzip12 (V_12 n_ as bs cs ds es fs gs hs is js ks ls) = (as,
                                                         bs,
                                                         cs,
                                                         ds,
                                                         es,
                                                         fs,
                                                         gs,
                                                         hs,
                                                         is,
                                                         js,
                                                         ks,
                                                         ls)
#endif
